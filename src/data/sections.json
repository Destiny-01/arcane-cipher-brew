{
  "sections": [
    {
      "id": 1,
      "title": "Unveiling the Mysteries of FHE",
      "subtitle": "Your First Steps into the Arcane Halls of Data Sorcery",
      "description": "Welcome, aspiring alchemists, to the arcane halls of data sorcery! In this first chamber of our 'Private Potion Brewing Simulator,' we'll lift the veil on Fully Homomorphic Encryption (FHE)—the ultimate spell in the grimoire of privacy. Imagine brewing a potent elixir in a sealed cauldron: you mix enchanted ingredients without ever peeking inside, and only the final potion reveals its power. That's FHE in a nutshell—a magical encryption that lets you perform computations on hidden data, keeping secrets locked away from prying eyes. No more risky revelations during the brewing process! As we embark on this journey with Zama's groundbreaking tools, you'll see how FHE transforms blockchain into a fortress of privacy, perfect for Web3 wizards like you who know Solidity but are new to cryptographic charms.",
      "learningObjectives": [
        "Define FHE and explain its core principles in simple, spellbinding terms",
        "Understand why FHE is a game-changer for data privacy, especially in blockchain realms like DeFi and voting",
        "Connect FHE to everyday privacy puzzles, such as analyzing health data without exposing personal secrets",
        "Trace the enchanted history of FHE and grasp its mechanics at a high level",
        "Appreciate how FHE builds on basic encryption concepts you might already know from your Web3 adventures"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "The Essence of FHE: Brewing Secrets in the Shadows"
        },
        {
          "type": "text",
          "content": "Let's start our incantation with the basics. Fully Homomorphic Encryption is a type of cryptographic spell that allows you to compute directly on encrypted data—called ciphertexts—without ever decrypting it first. The result? A new ciphertext that, when finally decrypted, matches what you'd get from computing on the plain, unencrypted data (plaintext). It's like whispering a command to a locked chest: the contents shuffle and transform inside, but the lock stays sealed until you're ready to open it."
        },
        {
          "type": "text",
          "content": "Why is this revolutionary? Traditional encryption, like the sturdy locks on your treasure vaults (think AES or RSA), forces you to decrypt data before any mixing or measuring—creating a vulnerable moment where thieves (hackers) could strike. FHE eliminates that weak spot entirely. Your data stays encrypted throughout the entire ritual, ensuring privacy even during complex operations."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "The Potion Master's Analogy",
          "content": "Picture yourself as a potion master. Your secret ingredient (data) is encrypted into a mystical vial. You add spells (operations like addition or multiplication) to the vial without breaking the seal. The vial computes internally, and only when you chant the decryption incantation does the final potion emerge—perfect and private."
        },
        {
          "type": "subheader",
          "text": "A Brief History of This Arcane Art"
        },
        {
          "type": "text",
          "content": "The quest for FHE began in the misty annals of 1978, when wizards Ron Rivest, Len Adleman, and Michael Dertouzos first pondered the idea of 'privacy homomorphisms'—encryption that preserves operations. For decades, it remained a theoretical dream, with partial successes along the way. The breakthrough came in 2009, courtesy of cryptographic sage Craig Gentry, who constructed the first fully homomorphic scheme using lattice-based magic (a branch of math involving grids of points in high dimensions)."
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "The Meaning of Homomorphic",
          "content": "No need for deep math here—just know that 'homomorphic' comes from Greek roots meaning 'same shape.' Operations on ciphertexts mirror those on plaintexts, preserving the structure of your spells. Since Gentry's breakthrough, optimizations have made FHE faster and more practical, thanks to companies like Zama."
        },
        {
          "type": "subheader",
          "text": "The Three Types of Homomorphic Spells"
        },
        {
          "type": "text",
          "content": "Not all homomorphic enchantments are created equal. As Zama's lore reveals, there are three tiers of power:"
        },
        {
          "type": "list",
          "items": [
            "**Partially Homomorphic Encryption (PHE)**: This spell masters one type of operation, performed unlimited times. For example, it might handle endless additions (like Paillier encryption) or multiplications (like ElGamal). Ideal for simple brews, such as tallying votes without revealing individual choices. Think of it as a cauldron that only stirs clockwise—effective, but limited.",
            "**Somewhat Homomorphic Encryption (SHE)**: A step up, this allows both additions and multiplications, but only a finite number of times before the magic weakens (due to 'noise' buildup in the ciphertext). It's like a potion that ferments perfectly for a few mixes but sours if overworked.",
            "**Fully Homomorphic Encryption (FHE)**: The pinnacle! Unlimited combinations of additions, multiplications, and beyond—enabling any computation. Zama's tfhe library powers this, turning theory into deployable dApps. With FHE, you can brew infinitely complex elixirs, from machine learning models to financial audits, all in secrecy."
          ]
        },
        {
          "type": "subheader",
          "text": "Real-World Enchantments: Why FHE Matters in Your Realm"
        },
        {
          "type": "text",
          "content": "FHE isn't just academic arcane—it's the key to unlocking privacy in our digital kingdoms. In blockchain, where transparency clashes with secrecy, FHE shines with transformative applications:"
        },
        {
          "type": "list",
          "items": [
            "**Private Medical Diagnosis**: Analyze encrypted health data in the cloud without exposing patient records. Doctors get insights; privacy stays intact.",
            "**Secure Financial Analysis**: Process transactions without revealing account details—perfect for confidential DeFi or fraud detection.",
            "**AI Inference**: Run machine learning models on encrypted inputs, keeping user data hidden from even the AI wizards."
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "FHE in Web3: The fhEVM Revolution",
          "content": "Zama's fhEVM (Fully Homomorphic Ethereum Virtual Machine) integrates FHE into smart contracts. Imagine sealed-bid auctions where bids compute privately, or confidential voting where tallies happen without exposing votes. No more trusting third-party oracles; the blockchain itself becomes a private computation engine. Compared to zero-knowledge proofs, FHE excels in scenarios needing ongoing computations on shared encrypted data."
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting for Novice Sorcerers"
        },
        {
          "type": "text",
          "content": "Beware these curses in your FHE journey:"
        },
        {
          "type": "list",
          "items": [
            "**Misconception: FHE is Too Slow for Real Use**: Not completely true. It was compute-intensive (operations can be 100-1000x slower than plaintext), but Zama's optimizations and hardware accelerations closed the gap, and they are now 100x faster FHE from 5 years back",
            "**Overcomplicating the Math**: You don't need a PhD in computing or encryption, Zama's docs handle the heavy lifting. If stuck, refer to their official guides.",
            "**Resource Consumption**: Test on testnets like Sepolia first to avoid gas guzzlers—FHE ops consume more resources."
          ]
        },
        {
          "type": "tip",
          "icon": "zap",
          "title": "Quick Debugging Spell",
          "content": "If your spells fizzle, double-check library versions and consult Zama's troubleshooting forums. Check their GitHub for starter templates to ensure your setup is enchanted correctly."
        },
        {
          "type": "subheader",
          "text": "Key Takeaways: Seal These in Your Spellbook"
        },
        {
          "type": "list",
          "items": [
            "FHE is the spell for computing on encrypted data without decryption, banishing privacy vulnerabilities",
            "From partial to full homomorphic tiers, it evolves to handle any operation, powering Zama's fhEVM for blockchain privacy",
            "Real-world magic: Secure health, finance, and AI without exposure—essential for trustless Web3 dApps",
            "History shows it's no myth: From 1978 theory to 2009 reality, now practical thanks to innovators like Zama"
          ]
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "FHE Workflow: Traditional vs. Homomorphic",
          "code": "// ❌ Traditional Encryption Workflow (VULNERABLE)\nconst secretData = decrypt(encryptedData);  // Data exposed!\nconst result = compute(secretData);         // Processing in the open\nconst output = encrypt(result);             // Re-encrypt\n\n// ✅ FHE Workflow (SECURE)\nconst encryptedResult = computeOnEncrypted(encryptedData);  // Never exposed!\nconst output = decrypt(encryptedResult);     // Only final result revealed\n\n// The magic: operations happen directly on ciphertext\n// Enc(a) + Enc(b) = Enc(a + b)\n// Enc(a) × Enc(b) = Enc(a × b)"
        }
      ],
      "resources": [
        {
          "title": "Zama Official Documentation",
          "url": "https://docs.zama.ai/"
        },
        {
          "title": "fhEVM Solidity Guide",
          "url": "https://docs.zama.ai/protocol/solidity-guides"
        },
        {
          "title": "Introduction to FHE",
          "url": "https://www.zama.ai/introduction-to-homomorphic-encryption"
        }
      ]
    },
    {
      "id": 2,
      "title": "Entering the FHEVM Realm",
      "subtitle": "Basics, Cryptography, Data Types, and Operations",
      "description": "Hello again, privacy pioneers! We're stepping into the fhEVM realm – Zama's clever twist on the Ethereum Virtual Machine that lets you cast confidential spells on the blockchain. Picture it as an enchanted EVM where data stays hidden in ciphertexts, yet computations hum along seamlessly. No more exposing secrets during smart contract executions! This section builds on FHE basics, breaking down fhEVM's nuts and bolts in a straightforward way, with real examples to make it stick. We'll keep the magic light but engaging, focusing on clear explanations so you can confidently build privacy-preserving dApps like our Private Potion Guesser.",
      "learningObjectives": [
        "Explain what fhEVM is and how it integrates FHE into Ethereum-compatible smart contracts",
        "Describe key cryptography concepts like keys, ciphertexts, the TFHE scheme, and noise management",
        "Identify fhEVM's encrypted data types and how they differ from standard Solidity ones",
        "Perform basic operations on encrypted data, understanding examples, limitations, and best practices"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "fhEVM Overview: The Confidential Blockchain Engine"
        },
        {
          "type": "text",
          "content": "fhEVM is Zama's open-source framework that extends the standard EVM to support Fully Homomorphic Encryption. It's essentially an EVM fork with built-in FHE capabilities, allowing smart contracts to compute on encrypted data without decryption. This means your dApps can handle sensitive info – like private guesses in our game – while keeping everything confidential onchain."
        },
        {
          "type": "text",
          "content": "How does it work? fhEVM uses symbolic execution: Instead of computing values directly, it handles 'ciphertext handles' (references to encrypted data). Heavy computations are offloaded to a coprocessor, making it efficient for blockchains. It's compatible with EVM tools like Hardhat and deploys to networks like Sepolia. The magic? Data privacy without sacrificing verifiability – perfect for DeFi, voting, or our potion guessing where the target number stays secret."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Web3 Connection",
          "content": "If you're familiar with Solidity, fhEVM adds a library (tfhe.sol) to your contracts, letting you mix encrypted ops with regular code. It's production-ready, quantum-resistant, and open-source on GitHub."
        },
        {
          "type": "subheader",
          "text": "Cryptography Concepts: The Building Blocks of Privacy"
        },
        {
          "type": "text",
          "content": "Let's demystify the crypto behind fhEVM – no deep math required, just the essentials for building."
        },
        {
          "type": "list",
          "items": [
            "**Public and Private Keys**: fhEVM uses a global public key (fetched via frontend libraries) for encrypting data client-side. The private key is split across a decentralized Key Management System (KMS) using threshold MPC – no single entity holds the full key. This ensures secure decryption only when authorized, with zero-knowledge proofs verifying inputs.",
            "**Ciphertexts**: Your encrypted data! Operations produce new ciphertexts without revealing plaintext. In contracts, they're handled as opaque references to prevent leaks.",
            "**TFHE Scheme**: fhEVM is powered by Zama's TFHE (Threshold Fully Homomorphic Encryption), a lattice-based scheme that's fast for Boolean ops and supports unlimited computations. It's quantum-safe and handles integers up to 256 bits.",
            "**Noise Management**: FHE adds 'noise' to ciphertexts during ops to maintain security. Too much noise? Data becomes undecryptable. TFHE uses programmable bootstrapping to 'refresh' ciphertexts, reducing noise and enabling deep computations without limits."
          ]
        },
        {
          "type": "tip",
          "icon": "lock",
          "title": "Privacy Guarantee",
          "content": "These concepts ensure your dApp's privacy: Encrypt once, compute forever, decrypt only at the end."
        },
        {
          "type": "subheader",
          "text": "Data Types in fhEVM: Encrypted Twins of Solidity Staples"
        },
        {
          "type": "text",
          "content": "fhEVM introduces prefixed 'e' types for encrypted data, mirroring Solidity's but with privacy superpowers. They store ciphertexts, not values, so you can't peek inside – that's the point!"
        },
        {
          "type": "list",
          "items": [
            "**ebool**: Encrypted boolean for true/false decisions",
            "**euintX**: Encrypted unsigned integers (e.g., euint8 for 8-bit, up to euint256 for big numbers). Use smaller bits for efficiency",
            "**eaddress**: Encrypted Ethereum addresses",
            "**External Types**: Like externalEuint8 for handling frontend-encrypted inputs"
          ]
        },
        {
          "type": "text",
          "content": "Difference from standard? Regular uint is plaintext; euint is ciphertext. Cast with FHE.asEuintX(value) for plaintext to encrypted, or handle external inputs directly."
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Data Types Example",
          "code": "import { FHE, euint8 } from \"@fhevm/solidity/lib/FHE.sol\";\n\n// Encrypt plaintext as euint8\neuint8 secretNumber = FHE.asEuint8(42); // Produces an encrypted version of 42"
        },
        {
          "type": "subheader",
          "text": "Supported Operations: Casting Spells on Ciphertexts"
        },
        {
          "type": "text",
          "content": "Using the FHE library (imported from @fhevm/solidity/lib/FHE.sol), fhEVM supports ops via FHE functions. They're like Solidity ops but privacy-preserving."
        },
        {
          "type": "list",
          "items": [
            "**Arithmetic**: Add (FHE.add), subtract (FHE.sub), multiply (FHE.mul), min/max (FHE.min/max)",
            "**Bitwise**: AND (FHE.and), OR (FHE.or), XOR (FHE.xor)",
            "**Comparisons**: Equal (FHE.eq), not equal (FHE.ne), less than (FHE.lt), greater than (FHE.gt), etc.",
            "**Advanced**: Select (FHE.select for if-else on encrypted conditions), random (FHE.randEuint8 for onchain randomness)"
          ]
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Operation Examples",
          "code": "// Arithmetic: Add two encrypted integers\neuint32 sum = FHE.add(a, b);\n\n// Bitwise: OR encrypted values\neuint16 result = FHE.or(x, y);\n\n// Comparison: Check equality\nebool isEqual = FHE.eq(guess, target);\n\n// Advanced: Conditional select\neuint64 choice = FHE.select(condition, optionA, optionB);"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Import Errors**: Always import '@fhevm/solidity/lib/FHE.sol'; missing it causes 'FHE not found'",
            "**Gas Overruns**: FHE ops cost more - optimize by using smaller euint types and test on local nodes",
            "**Type Mismatches**: Operations need matching types; cast with FHE.asEuintX"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "fhEVM brings FHE to EVM via TFHE, using symbolic execution for private computations",
            "Crypto essentials: Global keys, ciphertexts, noise refreshed via bootstrapping",
            "Data types like euintX enable encrypted logic; operations mirror Solidity but secure",
            "Master these for dApps where privacy wins – with awareness of gas and limits"
          ]
        }
      ],
      "resources": [
        {
          "title": "fhEVM Solidity Guides",
          "url": "https://docs.zama.ai/protocol/solidity-guides"
        },
        {
          "title": "FHE Operations Documentation",
          "url": "https://docs.zama.ai/protocol/solidity-guides/smart-contract/operations"
        }
      ]
    },
    {
      "id": 3,
      "title": "Brewing Our First Confidential Potion",
      "subtitle": "Project Overview, Tools, and Prerequisites",
      "description": "Excited yet? Let's outline our star project: the Private Potion Guesser dApp! It's a fun, hands-on way to apply fhEVM – users guess an encrypted potion's 'strength' (a secret number), and the contract checks it privately without spilling secrets. Think of it as a magical lockbox: Your guess goes in encrypted, computation happens inside, and only the 'yes/no' peeks out. This section previews the build, lists tools, and checks prereqs, keeping things simple and motivating so you're geared up to code.",
      "learningObjectives": [
        "Describe the dApp's mechanics and how fhEVM ensures privacy in the guessing process",
        "List key tools and their roles in the full-stack build",
        "Verify prerequisites like software versions and setups",
        "Grasp the end-to-end workflow to build excitement for coding"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Project Overview: A Private Guessing Adventure"
        },
        {
          "type": "text",
          "content": "In the Private Potion Guesser:"
        },
        {
          "type": "list",
          "items": [
            "The smart contract holds an encrypted target number (set by the deployer)",
            "On the frontend, users encrypt their guess using the public key",
            "The contract compares (e.g., FHE.eq) on ciphertexts, returning an encrypted result",
            "User decrypts offchain via threshold KMS, seeing score on leaderboard"
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Privacy Win",
          "content": "Blockchain sees only ciphertexts – no leaks! It's simple yet demonstrates the full FHE loop: Encrypt → Compute → Decrypt. We'll build it end-to-end, deploying to Sepolia for real-world feel."
        },
        {
          "type": "text",
          "content": "Why this project? It's beginner-accessible, creative (inspired by Zama's secret number ideas), and teaches core fhEVM without overwhelm."
        },
        {
          "type": "subheader",
          "text": "Required Tools: Your Builder's Toolkit"
        },
        {
          "type": "text",
          "content": "Here's what we'll use – all free and Web3-standard:"
        },
        {
          "type": "list",
          "items": [
            "**Hardhat**: Compiles, tests, deploys contracts. Great for local sims",
            "**Zama Relayer SDK**: Frontend JS lib for encryption/decryption with fhEVM's keys",
            "**Wagmi/Viem**: Handles wallet connections and contract calls (e.g., MetaMask integration)",
            "**React/Next.js**: Builds the UI – inputs, buttons, results display",
            "**Sepolia Testnet**: Safe Ethereum playground; use Alchemy/Infura for RPC",
            "**MetaMask**: Wallet for testing interactions and funding"
          ]
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "Tool Integration",
          "content": "These snap together: Hardhat for backend, React for frontend, relayer-sdk bridging encryption."
        },
        {
          "type": "subheader",
          "text": "Prerequisites: Check Your Setup"
        },
        {
          "type": "text",
          "content": "Before brewing:"
        },
        {
          "type": "list",
          "items": [
            "**Node.js**: v18+ (LTS recommended; check with `node -v`)",
            "**Package Manager**: NPM or Yarn",
            "**Git**: For cloning templates",
            "**MetaMask**: Add Sepolia (Chain ID 11155111), fund via faucet",
            "**Basic Skills**: Solidity basics, React hooks; no FHE needed – we'll teach that!"
          ]
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Quick Verify",
          "code": "# Check your versions\nnode -v && npm -v\n\n# Should show compatible versions (Node 18+)"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Node Version Mismatch**: If <18, update via nvm or official site",
            "**Wallet Funding**: No ETH? Transactions fail – use faucets daily",
            "**Editor Setup**: VS Code + Solidity/React extensions for auto-complete and errors"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "The dApp uses fhEVM for private guesses, showcasing encrypt-compute-decrypt",
            "Tools cover full stack; prereqs are straightforward Web3 basics",
            "This sets a fun foundation – ready to clone and code!"
          ]
        }
      ],
      "resources": [
        {
          "title": "Sepolia Faucet",
          "url": "https://sepolia-faucet.com"
        },
        {
          "title": "Node.js Download",
          "url": "https://nodejs.org/"
        }
      ]
    },
    {
      "id": 4,
      "title": "Gathering Your Alchemy Kit",
      "subtitle": "Cloning and Exploring the Boilerplate Repo",
      "description": "Welcome back, aspiring privacy alchemists! In this crucial step, we'll summon our development toolkit by cloning a customized boilerplate repository – imagine it as discovering a well-stocked wizard's workshop, complete with enchanted scrolls and potions ready to mix. The repo we'll use is https://github.com/Destiny-01/potion-brew, a version of PotionBrew with just the frontend. It's cloned from the fhevm-react-template which is designed specifically for building frontend interfaces that interact with fhEVM smart contracts, making it perfect for our Private Potion Guesser dApp.",
      "learningObjectives": [
        "Clone the repo, install dependencies, and set up your local environment with clear, beginner-friendly steps",
        "Understand the overall purpose of the repo as a boilerplate for fhEVM dApps, including how it ties into our Private Potion Guesser",
        "Navigate key folders and files, with explanations of their roles, contents, and why they're important – focusing on the packages folder",
        "Grasp supporting concepts like environment variables (e.g., MNEMONIC) and how they fit into secure development"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Why This Repo? A Quick Overview"
        },
        {
          "type": "text",
          "content": "This repository, is a minimal version of Potion Brew optimized for Fully Homomorphic Encryption (FHE)-enabled dApps on Ethereum. It pairs seamlessly with Zama's fhEVM Hardhat template (which we'll cover in later sections for the backend contracts). The focus here is on the frontend: It provides hooks for interacting with fhEVM contracts, wallet management, and basic UI setups."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Perfect for Our Project",
          "content": "For our Private Potion Guesser, it's customized to handle encrypted inputs (like guesses) and display private results without leaks. Think of it as your starting canvas – we'll paint our guessing game UI on top."
        },
        {
          "type": "text",
          "content": "If you're wondering, a 'boilerplate' is like a recipe template: It gives you the basics so you can focus on the fun parts, like adding your own spells (code). This one includes dependencies for React, Next.js (for building dynamic apps), Tailwind CSS (for easy styling), and Zama's libraries for FHE magic."
        },
        {
          "type": "subheader",
          "text": "Step-by-Step Setup: Cloning and Installation"
        },
        {
          "type": "text",
          "content": "Let's get hands-on. Open your terminal (that's the command-line interface – on Windows, use Command Prompt or PowerShell; on Mac/Linux, the built-in Terminal app). If you're new to terminals, it's just a text-based way to run commands – no worries, we'll go slow."
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Clone and Install",
          "code": "# 1. Clone the repository\ngit clone https://github.com/Destiny-01/potion-brew.git\n\n# 2. Navigate into the folder\ncd potion-brew\n\n# 3. Install dependencies\nnpm install\n# Or if you prefer Yarn: yarn install"
        },
        {
          "type": "tip",
          "icon": "zap",
          "title": "Installation Tips",
          "content": "If Git isn't installed, download it from https://git-scm.com. If npm install fails, ensure Node.js is installed (download from https://nodejs.org – aim for LTS version 18+). This might take a few minutes as it downloads packages."
        },
        {
          "type": "subheader",
          "text": "Exploring the Repo Structure: Folders and Files"
        },
        {
          "type": "text",
          "content": "The repo is organized as a monorepo, meaning everything lives under the root, with the main action in the packages folder. This keeps things modular – you can build and test parts independently. We'll prioritize the most important areas: the packages/site subfolder (the core frontend), root-level configs, and supporting files."
        },
        {
          "type": "list",
          "items": [
            "**README.md**: Your ultimate guidebook – open this first. It explains the repo's purpose, features (like React integration with fhEVM), requirements (e.g., MetaMask wallet), and quickstart steps.",
            "**package.json**: The project's blueprint. It lists all dependencies (e.g., react and next for the app, tailwindcss for styling) and scripts (commands you can run). Scripts like `npm run dev` start the frontend server",
            "**Configuration Files**: Files like .eslintrc (sets rules for JavaScript linting), .prettierrc (auto-formats code), and tailwind.config.js (customizes Tailwind CSS themes) enforce code quality and style. They keep your code clean and professional"
          ]
        },
        {
          "type": "subheader",
          "text": "The packages Folder: Your Frontend Workshop"
        },
        {
          "type": "text",
          "content": "This is the heart – a sub-package called site houses the actual React app. It's where you'll spend most time adding components for our Potion Guesser (e.g., input fields for guesses, buttons to submit)."
        },
        {
          "type": "list",
          "items": [
            "**packages/site/**: The main frontend directory containing the app's entry points and reusable code. It builds the user interface for interacting with fhEVM contracts – encrypting data, connecting wallets, and displaying results privately",
            "**fhevm/ subfolder**: Contains hooks (reusable functions) for fhEVM interactions. These are the 'spells' that fetch the global public key, handle encryption calls, and manage contract responses. For our dApp, you'll use these to encrypt guesses before sending them to the contract",
            "**hooks/ subfolder**: Custom React hooks for logic separation, including usePotionContract.tsx (a simple hook where we'll write out code to interact with a simple fhEVM contract)",
            "**Other Contents**: Expect src/ or app/ for pages (e.g., main guessing page), components/ for UI bits (like buttons/forms), and styles/ for CSS."
          ]
        },
        {
          "type": "subheader",
          "text": "Key Concepts Explained"
        },
        {
          "type": "list",
          "items": [
            "**MNEMONIC**: This is a 'seed phrase' – a series of 12-24 words (e.g., 'apple banana cat...') that generates your wallet's private keys. In this repo, it's used in environment variables for Hardhat setups. Set it in a .env file (create one in the root: MNEMONIC='your test phrase here'). Never share it – it's like a master key!",
            "**Environment Variables (.env)**: Secure way to store secrets like API keys or MNEMONIC. The repo might reference INFURA_API_KEY (for connecting to Sepolia via Infura). Add them to .env and load with dotenv – keeps your code safe from leaks"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Installation Errors**: If npm install fails, try `npm cache clean --force` or update Node.js",
            "**Git Issues**: Run `git --version` to confirm Git is installed",
            "**Missing Files**: If something's absent, pull updates: `git pull origin main`",
            "**Editor Setup**: Open in VS Code (free from https://code.visualstudio.com) – install extensions for React and Solidity for highlighting"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Cloning and installing gives you a ready fhEVM React boilerplate, focused on packages/site for frontend magic",
            "Files like README.md guide you; hooks in fhevm and metamask handle privacy and wallets",
            "Concepts like MNEMONIC ensure secure dev – now customize for our Potion Guesser!",
            "You're set to ignite the cauldron in the next section"
          ]
        }
      ],
      "resources": [
        {
          "title": "Potion Brew Repository",
          "url": "https://github.com/Destiny-01/potion-brew"
        },
        {
          "title": "Git Download",
          "url": "https://git-scm.com"
        },
        {
          "title": "Node.js Download",
          "url": "https://nodejs.org"
        }
      ]
    },
    {
      "id": 5,
      "title": "Igniting the Cauldron",
      "subtitle": "Setting Up Hardhat, React, and Environment",
      "description": "Alright, alchemists, let's spark the flames! With our repo cloned, this section guides you through configuring the environment for deployment to Sepolia testnet – Ethereum's safe playground for testing dApps. We'll focus on real-world setup: Adding Sepolia to your wallet, funding it with test ETH, deploying your contract, and interacting with it. No local simulations here – we'll go straight to the testnet for hands-on experience.",
      "learningObjectives": [
        "Add and fund the Sepolia testnet in MetaMask for secure interactions",
        "Configure Hardhat with environment variables for Sepolia deployment",
        "Deploy a sample contract to Sepolia and verify it works",
        "Interact with your deployed contract from the frontend, ensuring everything connects smoothly"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Prerequisites Check: Make Sure You're Ready"
        },
        {
          "type": "text",
          "content": "Before diving in, confirm you have:"
        },
        {
          "type": "list",
          "items": [
            "Node.js v18+ installed (run `node -v` in terminal)",
            "MetaMask browser extension (download from https://metamask.io if needed)",
            "Your cloned repo open in an editor like VS Code",
            "An Infura account (free at https://infura.io – sign up for an API key)"
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Important",
          "content": "Sepolia is free and forgiving – mistakes won't cost real money. If anything's missing, pause and set it up – we'll use these throughout."
        },
        {
          "type": "subheader",
          "text": "Step 1: Adding Sepolia to MetaMask"
        },
        {
          "type": "text",
          "content": "MetaMask is your digital wallet for Ethereum – it holds test ETH and signs transactions."
        },
        {
          "type": "list",
          "items": [
            "Open MetaMask in your browser (click the fox icon)",
            "Click the network dropdown (top center, probably says 'Ethereum Mainnet')",
            "Select 'Add network' > 'Add a network manually'",
            "Fill in the details as shown below",
            "Save – now switch to Sepolia in the dropdown"
          ]
        },
        {
          "type": "code",
          "language": "text",
          "title": "Sepolia Network Configuration",
          "code": "Network Name: Sepolia\nNew RPC URL: https://ethereum-sepolia-rpc.publicnode.com\nChain ID: 11155111\nCurrency Symbol: ETH\nBlock Explorer URL: https://sepolia.etherscan.io"
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "Why Sepolia?",
          "content": "Sepolia mimics mainnet but uses fake ETH, perfect for testing our dApp without risks."
        },
        {
          "type": "subheader",
          "text": "Step 2: Funding Your Wallet with Test ETH (Faucet)"
        },
        {
          "type": "text",
          "content": "Deployments need gas (fees), so grab free test ETH from a faucet."
        },
        {
          "type": "list",
          "items": [
            "Go to a Sepolia faucet like https://sepoliafaucet.com or https://www.infura.io/faucet/sepolia",
            "Connect MetaMask (click 'Connect Wallet')",
            "Enter your wallet address (copy from MetaMask: Click account > Copy)",
            "Request ETH – usually 0.01-0.1 ETH per day. Wait a minute; check balance in MetaMask"
          ]
        },
        {
          "type": "note",
          "icon": "zap",
          "title": "Troubleshooting",
          "content": "If denied, try another faucet or wait 24 hours."
        },
        {
          "type": "subheader",
          "text": "Step 3: Configuring Hardhat for Sepolia"
        },
        {
          "type": "text",
          "content": "Hardhat is our tool for compiling and deploying Solidity contracts. We'll set it up with hardhat vars for security. Remember the wallet you created specifically for deployment? You can create one with metamask. Keep the 12-word recovery phrase"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "set hardhat variables",
          "code": "npx hardhat vars set MNEMONIC\n# You'll be asked to input the phrase, this is where you put it\n\nnpx hardhat vars set INFURA_API_KEY\n# Paste the key you got from infura here"
        },
        {
          "type": "tip",
          "icon": "lock",
          "title": "Security Warning",
          "content": "MNEMONIC is what gives access to your entire wallet and its keys - never give it out! Use a test account only!"
        },
        {
          "type": "subheader",
          "text": "Step 4: Deploying to Sepolia"
        },
        {
          "type": "text",
          "content": "Let's deploy the existing contract to Sepolia"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Deploy to Sepolia",
          "code": "npx hardhat run scripts/deploy.js --network sepolia\n\n# Watch for the transaction hash\n# Check on https://sepolia.etherscan.io (paste address)"
        },
        {
          "type": "text",
          "content": "Uhhhh!!! That failed. You know why? It's because the content of our functions are empty and they don't match the return values. Don't worry, we'll get to that in the next section"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**No ETH**: Claim faucet again",
            "**Network Issues**: Verify Infura API key is correct and active"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Sepolia setup with MetaMask and faucets enables real testnet deploys",
            "Hardhat with env vars (like MNEMONIC) handles secure deployments",
            "Real-world testing on Sepolia prepares you for production deployment"
          ]
        }
      ],
      "resources": [
        {
          "title": "MetaMask Download",
          "url": "https://metamask.io"
        },
        {
          "title": "Sepolia Faucet",
          "url": "https://sepoliafaucet.com"
        },
        {
          "title": "Infura Dashboard",
          "url": "https://infura.io"
        },
        {
          "title": "Sepolia Etherscan",
          "url": "https://sepolia.etherscan.io"
        }
      ]
    },
    {
      "id": 6,
      "title": "Brewing the Enchanted Contract",
      "subtitle": "From Plain Arithmetic to Private Potion Power",
      "description": "Welcome, blockchain alchemists! In this crucial chapter, we'll craft the heart of our Private Potion dApp: the Potion.sol smart contract. We'll start by examining a basic non-FHE version to expose its privacy vulnerabilities, then transform it using fhEVM's cryptographic magic to ensure all ingredient values, calculations, and scores remain encrypted end-to-end. You'll be working with a boilerplate contract where function bodies are empty – we'll guide you through filling them line by line, explaining each component's purpose and placement.",
      "learningObjectives": [
        "Understand the critical privacy flaws in standard Solidity contracts through a plain arithmetic example",
        "Build the Potion.sol contract step-by-step, mastering encrypted types and homomorphic operations",
        "Implement a privacy-preserving leaderboard system where scores remain encrypted yet comparable",
        "Test your implementation to verify encrypted computations work correctly"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "The Plain Version: Brewing in the Open"
        },
        {
          "type": "text",
          "content": "Before diving into encrypted magic, let's see why we need it. Consider this simple non-private potion contract that computes a power score from ingredients:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "PlainPotion.sol - Unencrypted Version",
          "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract PlainPotion {\n    mapping(address => uint16) public highestScore;\n    \n    function compute(\n        uint8 a,\n        uint8 b,\n        uint8 c,\n        uint8 d,\n        uint8 e\n    ) public returns (uint16) {\n        // Sum ingredients\n        uint16 sum = uint16(a) + uint16(b) + uint16(c) + uint16(d) + uint16(e);\n        \n        // Scale by 14 and add offset\n        uint16 score = sum * 14 + 300;\n        \n        // Update if higher\n        if (score > highestScore[msg.sender]) {\n            highestScore[msg.sender] = score;\n        }\n        \n        return score;\n    }\n}"
        },
        {
          "type": "note",
          "icon": "alert-triangle",
          "title": "Critical Privacy Flaw",
          "content": "Every transaction parameter is visible on the blockchain! Anyone can inspect transaction data to see: (1) Which ingredient values produce the highest scores, (2) Everyone's exact scores and ingredients, (3) Optimal strategies to win. This is like brewing your secret potion recipe in a glass cauldron on a public stage – zero privacy! Competitors can reverse-engineer winning formulas by watching transactions."
        },
        {
          "type": "text",
          "content": "**The Attack Vector**: A curious player could easily scan recent transactions, extract the input values that produced high scores, and copy those exact ingredients. The entire competition becomes meaningless because secrecy is impossible. This is where Fully Homomorphic Encryption (FHE) becomes essential."
        },
        {
          "type": "subheader",
          "text": "Enter fhEVM: Building the Private Potion Contract"
        },
        {
          "type": "text",
          "content": "Now let's build the real Potion.sol contract that uses Zama's fhEVM to keep all data encrypted. You should have a boilerplate file with empty function bodies. We'll fill them together, explaining every line. This contract processes 5 encrypted ingredients through a secure computation pipeline."
        },
        {
          "type": "text",
          "content": "**Step 1: License, Pragma, and Imports (Top of File)**"
        },
        {
          "type": "text",
          "content": "These lines should already be in your boilerplate. Here's what they do:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "File Header",
          "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {FHE, externalEuint8, euint8, euint16, ebool, externalEuint32} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";"
        },
        {
          "type": "note",
          "icon": "info",
          "title": "Understanding the Imports",
          "content": "**FHE library**: Provides encrypted types and operations. `externalEuint8` = encrypted data from clients, `euint8/euint16` = encrypted integers for computation, `ebool` = encrypted boolean. **SepoliaConfig**: Pre-configured settings for Zama's Sepolia testnet deployment. This handles all the cryptographic infrastructure setup automatically."
        },
        {
          "type": "text",
          "content": "**Step 2: Contract Declaration and State Variables**"
        },
        {
          "type": "text",
          "content": "Your boilerplate should have this structure. Let's understand each piece:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Contract Structure",
          "code": "contract Potion is SepoliaConfig {\n    mapping(address => euint16) public highestPlayerGuess;\n    mapping(address => bool) public hasPlayed;\n    address[] public players;\n    \n    event ComputeResult(euint16 value);"
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "State Variables Explained",
          "content": "**highestPlayerGuess**: Maps each player to their encrypted best score (`euint16` = encrypted 16-bit uint, range 0-65535). This stays encrypted onchain! **hasPlayed**: Tracks if an address participated before. **players**: Array of all player addresses for leaderboard retrieval. **ComputeResult event**: Emits encrypted scores for frontend tracking."
        },
        {
          "type": "subheader",
          "text": "Step 3: Building the compute Function"
        },
        {
          "type": "text",
          "content": "This is where the magic happens! The `compute` function takes 5 encrypted ingredients, processes them homomorphically, and updates the leaderboard. Let's build it line by line inside your empty function body."
        },
        {
          "type": "text",
          "content": "**Lines 1-5: Convert External Encrypted Inputs**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Input Conversion",
          "code": "        euint8 a = FHE.fromExternal(aExt, attestation);\n        euint8 b = FHE.fromExternal(bExt, attestation);\n        euint8 c = FHE.fromExternal(cExt, attestation);\n        euint8 d = FHE.fromExternal(dExt, attestation);\n        euint8 e = FHE.fromExternal(eExt, attestation);"
        },
        {
          "type": "note",
          "icon": "key",
          "title": "Why fromExternal?",
          "content": "The frontend sends encrypted data as `externalEuint8` handles. `FHE.fromExternal` verifies the attestation (proof the ciphertext is valid) and converts it to a contract-usable `euint8` type. This prevents malicious fake encrypted data. Each ingredient (a-e) represents an encrypted value between 0-255."
        },
        {
          "type": "text",
          "content": "**Lines 6-8: Homomorphic Arithmetic - Sum the Ingredients**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Computing Sum",
          "code": "        euint16 sum = FHE.add(\n            FHE.add(FHE.add(FHE.add(FHE.asEuint16(a), FHE.asEuint16(b)), FHE.asEuint16(c)), FHE.asEuint16(d)),\n            FHE.asEuint16(e)\n        );"
        },
        {
          "type": "note",
          "icon": "zap",
          "title": "Homomorphic Addition",
          "content": "**FHE.add** performs encrypted addition without decryption! We convert each `euint8` to `euint16` using `asEuint16` to prevent overflow (5 × 255 = 1275 > 255). The nested structure chains additions: ((((a+b)+c)+d)+e). The sum remains encrypted throughout – no plaintext ever exists."
        },
        {
          "type": "text",
          "content": "**Lines 9-10: Scale and Offset the Score**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Scaling",
          "code": "        euint16 scaled = FHE.mul(sum, FHE.asEuint16(14));\n        result = FHE.add(scaled, FHE.asEuint16(300));"
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Score Calculation Formula",
          "content": "**FHE.mul** multiplies the encrypted sum by 14 (also encrypted). Then **FHE.add** adds 300. This creates score range: minimum (5 × 0 × 14 + 300 = 300), maximum (5 × 255 × 14 + 300 = 18,150). The constants 14 and 300 are encrypted using `asEuint16` so the entire computation happens on ciphertexts. Result: a privacy-preserving power score!"
        },
        {
          "type": "text",
          "content": "**Lines 11-16: Player Registration and Previous Score Retrieval**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Player Tracking",
          "code": "        euint16 prevBest = highestPlayerGuess[msg.sender];\n\n        if (!hasPlayed[msg.sender]) {\n            players.push(msg.sender);\n            prevBest = FHE.asEuint16(0);\n            hasPlayed[msg.sender] = true;\n        }"
        },
        {
          "type": "note",
          "icon": "users",
          "title": "Leaderboard Management",
          "content": "First, we load the player's previous best score (encrypted). If they're new (`!hasPlayed`), we register them in the `players` array, set their previous best to encrypted zero (`FHE.asEuint16(0)`), and mark them as played. This builds our leaderboard tracking system."
        },
        {
          "type": "text",
          "content": "**Lines 17-19: Compare and Select Best Score (Encrypted Conditional)**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Encrypted Comparison",
          "code": "        ebool isHigher = FHE.gt(result, prevBest);\n        euint16 newBest = FHE.select(isHigher, result, prevBest);\n        highestPlayerGuess[msg.sender] = newBest;"
        },
        {
          "type": "note",
          "icon": "target",
          "title": "Homomorphic Comparison Magic",
          "content": "**FHE.gt** (greater than) compares encrypted values, returning an encrypted boolean (`ebool`). **FHE.select** is an encrypted if/else: if `isHigher` is true (encrypted), return `result`, else return `prevBest`. This updates the best score without ever decrypting! The blockchain never sees which score was higher or the actual values."
        },
        {
          "type": "text",
          "content": "**Lines 20-28: Permission Management and Event Emission**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Access Control",
          "code": "        FHE.allowThis(result);\n        FHE.allowThis(highestPlayerGuess[msg.sender]);\n\n        FHE.allow(result, msg.sender);\n        FHE.allow(newBest, msg.sender);\n\n        FHE.makePubliclyDecryptable(newBest);\n\n        emit ComputeResult(result);"
        },
        {
          "type": "note",
          "icon": "shield",
          "title": "fhEVM Permission System",
          "content": "**FHE.allowThis**: Lets the contract itself access encrypted values for future operations. **FHE.allow**: Grants the player permission to decrypt their own result and best score using their private key. **FHE.makePubliclyDecryptable**: Makes the best score requestable by anyone (for leaderboard reveals) after a delay. Without these permissions, encrypted data is completely inaccessible, even to the owner!"
        },
        {
          "type": "subheader",
          "text": "Step 4: The getAllHighestGuesses Function"
        },
        {
          "type": "text",
          "content": "This view function retrieves all players and their encrypted scores for leaderboard display. Fill in your empty function body:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Leaderboard Retrieval",
          "code": "        uint256 count = players.length;\n        guesses = new euint16[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            guesses[i] = highestPlayerGuess[players[i]];\n        }\n\n        return (players, guesses);"
        },
        {
          "type": "note",
          "icon": "list",
          "title": "How It Works",
          "content": "Creates an array of encrypted scores matching the players array. Loops through all registered players, copying their encrypted best scores. Returns both arrays to the frontend, which can decrypt the scores (if permitted) for display. The scores remain encrypted in transit and storage!"
        },
        {
          "type": "subheader",
          "text": "Complete Contract: Your Finished Code"
        },
        {
          "type": "text",
          "content": "If you've followed along correctly, your Potion.sol should now look like this complete version. Compare it with yours to verify:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Potion.sol - Complete Encrypted Contract",
          "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {FHE, externalEuint8, euint8, euint16, ebool, externalEuint32} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\n\ncontract Potion is SepoliaConfig {\n    mapping(address => euint16) public highestPlayerGuess;\n    mapping(address => bool) public hasPlayed;\n    address[] public players;\n\n    event ComputeResult(euint16 value);\n\n    function compute(\n        externalEuint8 aExt,\n        externalEuint8 bExt,\n        externalEuint8 cExt,\n        externalEuint8 dExt,\n        externalEuint8 eExt,\n        bytes calldata attestation\n    ) public returns (euint16 result) {\n        euint8 a = FHE.fromExternal(aExt, attestation);\n        euint8 b = FHE.fromExternal(bExt, attestation);\n        euint8 c = FHE.fromExternal(cExt, attestation);\n        euint8 d = FHE.fromExternal(dExt, attestation);\n        euint8 e = FHE.fromExternal(eExt, attestation);\n\n        euint16 sum = FHE.add(\n            FHE.add(FHE.add(FHE.add(FHE.asEuint16(a), FHE.asEuint16(b)), FHE.asEuint16(c)), FHE.asEuint16(d)),\n            FHE.asEuint16(e)\n        );\n\n        euint16 scaled = FHE.mul(sum, FHE.asEuint16(14));\n        result = FHE.add(scaled, FHE.asEuint16(300));\n\n        euint16 prevBest = highestPlayerGuess[msg.sender];\n\n        if (!hasPlayed[msg.sender]) {\n            players.push(msg.sender);\n            prevBest = FHE.asEuint16(0);\n            hasPlayed[msg.sender] = true;\n        }\n\n        ebool isHigher = FHE.gt(result, prevBest);\n        euint16 newBest = FHE.select(isHigher, result, prevBest);\n        highestPlayerGuess[msg.sender] = newBest;\n\n        FHE.allowThis(result);\n        FHE.allowThis(highestPlayerGuess[msg.sender]);\n\n        FHE.allow(result, msg.sender);\n        FHE.allow(newBest, msg.sender);\n\n        FHE.makePubliclyDecryptable(newBest);\n\n        emit ComputeResult(result);\n    }\n\n    function getAllHighestGuesses() public view returns (address[] memory allPlayers, euint16[] memory guesses) {\n        uint256 count = players.length;\n        guesses = new euint16[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            guesses[i] = highestPlayerGuess[players[i]];\n        }\n\n        return (players, guesses);\n    }\n}"
        },
        {
          "type": "subheader",
          "text": "Testing Your Implementation"
        },
        {
          "type": "text",
          "content": "Now for the moment of truth! We've prepared comprehensive tests to verify your contract works correctly. Run them from your project root:"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Run Tests",
          "code": "npx hardhat test"
        },
        {
          "type": "tip",
          "icon": "check-circle",
          "title": "What the Tests Verify",
          "content": "The test suite checks: (1) Contract deploys successfully, (2) Encrypted inputs are processed correctly, (3) Score computation formula works (sum × 14 + 300), (4) Leaderboard tracking updates properly, (5) Multiple players can compete independently, (6) Permissions are set correctly. **All tests should pass** if you've implemented the contract correctly!"
        },
        {
          "type": "note",
          "icon": "alert-circle",
          "title": "If Tests Fail",
          "content": "**Common issues**: Missing lines in function bodies (go back and compare with the complete contract), Incorrect FHE function names (check spelling: `FHE.add`, `FHE.mul`, `FHE.gt`, `FHE.select`), Wrong variable types (`euint8` vs `euint16`), Permission calls missing or in wrong order. Carefully compare your code with the complete version above, paying special attention to the exact line placement and syntax."
        },
        {
          "type": "subheader",
          "text": "Understanding What You Built"
        },
        {
          "type": "text",
          "content": "Congratulations! You've built a privacy-preserving leaderboard system. Let's review what makes this revolutionary:"
        },
        {
          "type": "list",
          "items": [
            "**End-to-End Encryption**: Ingredients are encrypted client-side, stay encrypted onchain during computation, and only decrypt for authorized users.",
            "**Homomorphic Operations**: Addition, multiplication, and comparison all happen on ciphertexts. The EVM never sees plaintext values.",
            "**Privacy-Preserving Leaderboard**: Scores are encrypted yet comparable. Players can compete without revealing strategies.",
            "**Selective Disclosure**: Players decrypt their own scores, but best scores can become publicly decryptable for leaderboard reveals.",
            "**Zero Knowledge to Blockchain**: Even validators processing transactions can't see ingredient values or scores – they only see encrypted blobs."
          ]
        },
        {
          "type": "tip",
          "icon": "lightbulb",
          "title": "Real-World Applications",
          "content": "This pattern extends beyond games: private voting (encrypted votes, public results), sealed-bid auctions (bids hidden until reveal), confidential DeFi (private balances/trades), medical data (encrypted records with selective access), supply chain (proprietary quantities/prices). fhEVM enables entirely new blockchain use cases impossible with public ledgers!"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Advanced Tips"
        },
        {
          "type": "list",
          "items": [
            "**Gas Costs**: FHE operations are more expensive than plaintext. Use smallest encrypted types possible (`euint8` over `euint32` when values fit).",
            "**Overflow Safety**: Always upcast before operations that might overflow. We use `euint16` for sum because 5 × `euint8` could exceed 255.",
            "**Permission Management**: Forgetting `FHE.allow` means users can't decrypt their data. Forgetting `FHE.allowThis` breaks future contract operations.",
            "**Attestation Importance**: Never skip attestation verification in `fromExternal` – it prevents malicious fake encrypted data.",
            "**Public Decryptability**: `makePubliclyDecryptable` has a delay before values become accessible. Plan your UX accordingly."
          ]
        },
        {
          "type": "tip",
          "icon": "terminal",
          "title": "Debugging Tips",
          "content": "Use Hardhat console.log for plaintext debugging (but only in test environments). Check Sepolia faucets if transactions fail (need TZAMA and Sepolia ETH). Monitor gas usage in tests to optimize. Use descriptive test names to quickly identify which functionality broke."
        },
        {
          "type": "subheader",
          "text": "Next Steps"
        },
        {
          "type": "text",
          "content": "With your contract complete and tested, you're ready to deploy and build the frontend! In the next section, we'll deploy to Zama's Sepolia testnet and integrate the contract with a React UI where users can encrypt ingredients, submit guesses, and view the leaderboard. The pieces are coming together – your private potion game is almost ready to brew! ✨"
        }
      ],
      "resources": [
        {
          "title": "Zama Solidity Guide",
          "url": "https://docs.zama.ai/protocol/solidity-guides"
        },
        {
          "title": "FHE Solidity Library Reference",
          "url": "https://github.com/zama-ai/fhevm"
        },
        {
          "title": "Hardhat Testing Guide",
          "url": "https://hardhat.org/hardhat-runner/docs/guides/test-contracts"
        },
        {
          "title": "Understanding Homomorphic Encryption under the hood",
          "url": "https://docs.zama.ai/protocol/zama-protocol-litepaper"
        }
      ]
    },
    {
      "id": 7,
      "title": "Launching the Spell",
      "subtitle": "Deploying the Contract and Integrating Frontend",
      "description": "Your smart contract is written and tested - now it's time to deploy it to the blockchain and connect your frontend! In this section, you'll deploy to Zama's Sepolia testnet, configure your frontend with the deployment artifacts, and implement wallet connection functionality. By the end, users will be able to connect their wallets, view their balances, and your dApp will be ready to interact with the deployed contract.",
      "learningObjectives": [
        "Deploy your Potion contract to Sepolia testnet using Hardhat",
        "Configure frontend with contract address and ABI from deployment artifacts",
        "Implement wallet connection with RainbowKit and Wagmi",
        "Read blockchain data to display leaderboard",
        "Understand the complete deployment-to-frontend workflow"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Part 1: Deploying Your Contract to Sepolia"
        },
        {
          "type": "text",
          "content": "Before your frontend can interact with the contract, it needs to exist on the blockchain! We'll deploy to Zama's Sepolia testnet, which is configured for FHE operations. The deployment script is already prepared - you just need to run it."
        },
        {
          "type": "text",
          "content": "**Prerequisites Check**"
        },
        {
          "type": "list",
          "items": [
            "Ensure you have Sepolia testnet ETH in your deployer wallet (get from https://sepoliafaucet.com/)",
            "Verify your `.env` file has `PRIVATE_KEY` set to your wallet's private key",
            "Confirm you're in the root directory of your smart contract project (where `hardhat.config.ts` exists)"
          ]
        },
        {
          "type": "text",
          "content": "**Run the Deployment Command**"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Deploy to Sepolia",
          "code": "yarn deploy:sepolia"
        },
        {
          "type": "note",
          "icon": "terminal",
          "title": "What Happens During Deployment",
          "content": "The deployment script compiles your contract, connects to Sepolia testnet, deploys the Potion contract, and saves the deployment artifacts (address and ABI) to `deployments/sepolia/Potion.json`. You'll see transaction hashes and the deployed contract address in your terminal. This process takes about 30-60 seconds."
        },
        {
          "type": "tip",
          "icon": "check-circle",
          "title": "Verify Deployment Success",
          "content": "After deployment, you should see output like 'Potion deployed to: 0x123...' and a confirmation message. Copy this address - you'll need it! You can also verify the deployment on Sepolia Etherscan (https://sepolia.etherscan.io/) by pasting the contract address."
        },
        {
          "type": "subheader",
          "text": "Part 2: Connecting Frontend to Deployed Contract"
        },
        {
          "type": "text",
          "content": "Now that your contract is deployed, your frontend needs to know where to find it and how to interact with it. This is done through the contract's **address** (where it lives on the blockchain) and **ABI** (Application Binary Interface - the 'instruction manual' for calling its functions)."
        },
        {
          "type": "text",
          "content": "**Step 1: Locate the Deployment Artifact**"
        },
        {
          "type": "text",
          "content": "Navigate to your smart contract project and find the file:"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Deployment Artifact Location",
          "code": "deployments/sepolia/Potion.json"
        },
        {
          "type": "text",
          "content": "Open this file. You'll see JSON containing the deployed contract address and the complete ABI. This is everything your frontend needs to communicate with your contract."
        },
        {
          "type": "text",
          "content": "**Step 2: Update Frontend Config**"
        },
        {
          "type": "text",
          "content": "In your **frontend project**, navigate to the config folder and open the existing `Potion.json` file:"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Frontend Config Location",
          "code": "config/Potion.json"
        },
        {
          "type": "text",
          "content": "**Replace the entire contents** of this frontend config file with the contents from your deployment artifact (`deployments/sepolia/Potion.json`). Copy everything from the deployment file and paste it into the frontend config file, then save."
        },
        {
          "type": "note",
          "icon": "info",
          "title": "Why This Step Matters",
          "content": "The frontend `Potion.json` is imported by your React app to configure the contract connection. By copying the deployment artifact, you're telling your frontend: 'Here's the contract address on Sepolia' and 'Here's how to call its functions (the ABI)'. Without this, your frontend wouldn't know where your contract lives or how to talk to it."
        },
        {
          "type": "tip",
          "icon": "lightbulb",
          "title": "Understanding the ABI",
          "content": "The ABI is automatically generated from your Solidity contract during compilation. It describes every function (name, parameters, return types), event, and error your contract has. Think of it as a menu at a restaurant - it tells you what you can order (call) and what ingredients (parameters) each dish needs. Your frontend uses this to construct properly formatted contract calls."
        },
        {
          "type": "subheader",
          "text": "Part 3: Setting Up Wallet Connection"
        },
        {
          "type": "text",
          "content": "With your contract deployed and configured, let's enable users to connect their wallets. We'll use RainbowKit for a beautiful connection UI and Wagmi hooks to interact with the connected wallet."
        },
        {
          "type": "text",
          "content": "**File 1: Configure Wagmi (`src/lib/wagmi.ts`)**"
        },
        {
          "type": "text",
          "content": "Find the `wagmi.ts` file in your frontend. You'll see an empty configuration. Replace it with this setup:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/lib/wagmi.ts",
          "code": "import { getDefaultConfig } from \"@rainbow-me/rainbowkit\";\nimport { sepolia } from \"wagmi/chains\";\n\nconst projectId = \"your-project-id-here\";\n\nexport const config = getDefaultConfig({\n  appName: \"Potion Brew\",\n  projectId,\n  chains: [sepolia],\n  ssr: false,\n});"
        },
        {
          "type": "note",
          "icon": "settings",
          "title": "Configuration Breakdown",
          "content": "**appName**: Displayed in wallet connection prompts. **projectId**: Your WalletConnect identifier. **chains**: Array of networks your app supports - we're using `sepolia` (Ethereum's testnet). **ssr: false**: Indicates this is a client-side only app (not server-side rendered), which is correct for this project."
        },
        {
          "type": "text",
          "content": "**File 2: Display Connected Wallet (`src/components/WalletConnect.tsx`)**"
        },
        {
          "type": "text",
          "content": "In the `WalletConnect.tsx` component, find the `ConnectedWalletDisplay` function with empty logic. Fill it in with this code:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/components/WalletConnect.tsx",
          "code": "function ConnectedWalletDisplay({ account }: { account: any }) {\n  const { address } = useAccount();\n  const { data: balance } = useBalance({ address });\n\n  const formatAddress = (addr: string) =>\n    `${addr.slice(0, 6)}...${addr.slice(-4)}`;\n\n  const formatBalance = (bal: any) =>\n    bal ? `${parseFloat(bal.formatted).toFixed(3)} ${bal.symbol}` : \"0.000 ETH\";\n\n  // ... rest of component UI (already in your boilerplate)\n}"
        },
        {
          "type": "note",
          "icon": "info",
          "title": "Understanding Wagmi Hooks",
          "content": "**useAccount()**: Returns wallet connection state including the connected address. Updates automatically when the user switches accounts or disconnects. **useBalance()**: Fetches the ETH balance for a given address. Pass the address from `useAccount()` to fetch the connected wallet's balance. These hooks are reactive - they re-fetch when dependencies change."
        },
        {
          "type": "note",
          "icon": "palette",
          "title": "Formatting for UX",
          "content": "**formatAddress()**: Converts '0x1234567890abcdef...' to '0x1234...cdef' for readability. Full addresses are long and hard to read. **formatBalance()**: Displays balance as '0.123 ETH' with 3 decimal places. The raw balance data comes with many decimals (wei precision) - formatting makes it human-readable."
        },
        {
          "type": "tip",
          "icon": "test-tube",
          "title": "Testing Wallet Connection",
          "content": "Save your changes and start the dev server (`npm run dev`). You should see a 'Connect Wallet' button. Click it, select MetaMask, and approve the connection. Your formatted address and ETH balance should appear. If you don't have Sepolia ETH, visit https://sepoliafaucet.com/ to get free testnet tokens."
        },
        {
          "type": "subheader",
          "text": "Part 4: Reading Contract Data (Leaderboard)"
        },
        {
          "type": "text",
          "content": "Now that wallets can connect, let's read data from your deployed contract. We'll fetch the leaderboard by calling the `getAllHighestGuesses` view function. This demonstrates how to read blockchain data without spending gas."
        },
        {
          "type": "text",
          "content": "**File: `src/hooks/usePotionContract.ts`**"
        },
        {
          "type": "text",
          "content": "Find the `fetchLeaderboard` function with mock data. Replace it with this implementation that actually calls your contract:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Reading Leaderboard Data",
          "code": "const fetchLeaderboard = useCallback(async () => {\n  if (!publicClient) return [];\n  \n  try {\n    setIsLoading(true);\n\n    // Call contract's view function\n    const result = await publicClient.readContract({\n      address: contractConfig.address,\n      abi: contractConfig.abi,\n      functionName: \"getAllHighestGuesses\",\n      args: [],\n    } as any);\n\n    // Destructure the returned arrays\n    const [players, guesses] = result as [string[], string[]];\n\n    if (guesses.length === 0) return [];\n\n    // For now, return with encrypted handles\n    // We'll decrypt these in Section 8\n    return players.map((player, idx) => ({\n      player,\n      guess: guesses[idx], // Still encrypted\n    }));\n  } catch (err: any) {\n    console.error(\"Error fetching leaderboard:\", err);\n    toast({\n      title: \"Failed to load leaderboard\",\n      description: \"Unable to fetch leaderboard data.\",\n      variant: \"destructive\",\n    });\n    return [];\n  } finally {\n    setIsLoading(false);\n  }\n}, [publicClient, toast]);"
        },
        {
          "type": "note",
          "icon": "book-open",
          "title": "How publicClient.readContract Works",
          "content": "**publicClient**: A Viem client configured for read-only operations (no wallet needed). **readContract()**: Calls view/pure functions on your contract - these are free (no gas) because they don't modify state. **functionName**: Must match exactly with your contract's function name. **args**: Array of function arguments (empty here because `getAllHighestGuesses` takes no parameters). The function returns whatever your contract returns - in this case, two arrays."
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Why Guesses Are Still Encrypted",
          "content": "The `guesses` array contains encrypted `euint16` handles (strings like '0x123...'). These are still encrypted onchain! In Section 8, you'll implement the FHE decryption logic to convert these handles into actual numbers. For now, you're successfully reading the encrypted data - that's progress!"
        },
        {
          "type": "tip",
          "icon": "check-circle",
          "title": "Testing Leaderboard Fetch",
          "content": "After implementing this, your leaderboard component should load without errors (though it may be empty if no one has played yet, or show encrypted handles). Check the browser console - you should see the raw contract response logged. No errors here means your frontend is successfully communicating with your deployed contract!"
        },
        {
          "type": "subheader",
          "text": "Understanding the Deployment Flow"
        },
        {
          "type": "text",
          "content": "Let's recap what you've accomplished and how the pieces fit together:"
        },
        {
          "type": "list",
          "items": [
            "**Contract Deployment**: Your Solidity contract was compiled, deployed to Sepolia, and given a permanent address on the blockchain.",
            "**Artifact Generation**: Hardhat created `Potion.json` containing the address and ABI - the 'coordinates and instruction manual' for your contract.",
            "**Frontend Configuration**: By copying this artifact to your frontend, you linked your UI to the deployed contract.",
            "**Wallet Connection**: RainbowKit + Wagmi enable users to connect their wallets, providing the address and signer needed for transactions.",
            "**Data Reading**: Viem's `publicClient` lets you call view functions to read blockchain state without gas costs.",
            "**Current State**: Your dApp can now connect wallets and read contract data. The encrypted values are fetched successfully - decryption comes next!"
          ]
        },
        {
          "type": "note",
          "icon": "workflow",
          "title": "The Full Data Flow",
          "content": "Here's how data flows in your dApp: (1) User connects wallet via RainbowKit, (2) Frontend reads contract address/ABI from `Potion.json`, (3) Viem's publicClient calls contract view functions, (4) Contract returns encrypted data, (5) Frontend receives the response. In Section 8, we'll add: (6) FHE SDK decrypts the data, (7) UI displays plaintext results."
        },
        {
          "type": "subheader",
          "text": "Troubleshooting Common Issues"
        },
        {
          "type": "list",
          "items": [
            "**Deployment fails with 'insufficient funds'**: Get Sepolia ETH from https://sepoliafaucet.com/. You need ~0.05 ETH for deployment.",
            "**Cannot find Potion.json**: Make sure you're in the correct project directory. Smart contract project for deployment, frontend project for config update.",
            "**Wallet won't connect**: Verify you have MetaMask installed and are on the Sepolia network. Check that your WalletConnect Project ID is valid.",
            "**'Contract not found' error**: Ensure you copied the deployment artifact correctly. The address in frontend `Potion.json` must match your deployed contract.",
            "**Leaderboard shows nothing**: If no one has played yet, the arrays are empty - this is expected",
            "**TypeScript errors in IDE**: Run `npm install` to ensure all dependencies are installed. Some IDEs need a restart to pick up new types."
          ]
        },
        {
          "type": "tip",
          "icon": "bug",
          "title": "Debugging Tips",
          "content": "Open browser DevTools (F12) and check the Console tab for errors. Network tab shows contract calls - look for successful responses. If you see errors, read them carefully - they often tell you exactly what's wrong (e.g., 'wrong network', 'contract not found'). Check that MetaMask is connected to Sepolia, not mainnet or another testnet."
        },
        {
          "type": "subheader",
          "text": "What's Next: Encryption Magic Awaits"
        },
        {
          "type": "text",
          "content": "You've successfully deployed your contract and built the basic frontend infrastructure. Users can connect wallets and your app can read contract data. But the leaderboard still shows encrypted handles, and there's no way to submit potions yet. That's where Section 8 comes in!"
        },
        {
          "type": "text",
          "content": "In the next section, you'll implement the FHE encryption magic that makes this dApp truly private. You'll learn to:"
        },
        {
          "type": "list",
          "items": [
            "Initialize the Zama FHE SDK in your React app",
            "Encrypt user input client-side before sending to the blockchain",
            "Submit encrypted transactions with proper handle formatting",
            "Request private decryption using EIP-712 signatures",
            "Decrypt public leaderboard data for display",
            "Handle the complete encrypted transaction lifecycle with user feedback"
          ]
        },
        {
          "type": "tip",
          "icon": "rocket",
          "title": "Ready for the Next Challenge?",
          "content": "Make sure everything in this section works before moving on. Your wallet should connect, your balance should display, and the leaderboard should load (even if empty). Once these basics work, you're ready for the encryption magic in Section 8. Test thoroughly now - it's easier to debug connection issues separately from encryption issues!"
        }
      ],
      "resources": [
        {
          "title": "Sepolia Faucet",
          "url": "https://sepoliafaucet.com/"
        },
        {
          "title": "Wagmi Documentation",
          "url": "https://wagmi.sh/react/getting-started"
        },
        {
          "title": "Viem Documentation",
          "url": "https://viem.sh/docs/getting-started"
        },
        {
          "title": "Sepolia Etherscan",
          "url": "https://sepolia.etherscan.io/"
        }
      ]
    },
    {
      "id": 8,
      "title": "The Art of Secret Infusion",
      "subtitle": "Frontend Encryption and Decryption with FHEvm",
      "description": "Welcome to the cryptographic heart of your dApp! In this section, you'll implement Fully Homomorphic Encryption (FHE) on the client side, enabling true privacy for your potion game. You'll learn to encrypt user input before it touches the blockchain, submit encrypted transactions, request private decryption with cryptographic signatures, and decrypt public leaderboard data. This is where your dApp transcends traditional blockchain transparency to achieve genuine privacy.",
      "learningObjectives": [
        "Initialize and configure the Zama FHE SDK in your React application",
        "Encrypt user input client-side using FHE before blockchain submission",
        "Submit encrypted transactions with proper handle formatting and attestation",
        "Implement EIP-712 signature-based private decryption for user-specific data",
        "Decrypt publicly decryptable data for leaderboard display",
        "Handle the complete encrypted transaction lifecycle with comprehensive error handling"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Understanding the FHE Architecture"
        },
        {
          "type": "text",
          "content": "Before diving into code, let's understand what makes FHE special. In traditional blockchain apps, all data is public - anyone can see transaction inputs and contract state. FHE changes this by allowing computations on encrypted data. Your contract never sees plaintext values; it operates on ciphertexts directly. The Zama FHE SDK handles encryption client-side and works with a relayer service for decryption."
        },
        {
          "type": "list",
          "items": [
            "**Client Encryption**: User selects potions → SDK encrypts locally → Produces ciphertext handles + attestation proof",
            "**Blockchain Submission**: Encrypted handles sent to contract → Contract computes on ciphertexts → Emits encrypted result",
            "**Private Decryption**: User requests decryption → Signs EIP-712 message → Relayer decrypts with proof of ownership",
            "**Public Decryption**: Contract marks values public → Anyone can request → Relayer decrypts without signature"
          ]
        },
        {
          "type": "note",
          "icon": "shield",
          "title": "Privacy Guarantee",
          "content": "With FHE, the blockchain, validators, block explorers - no one can see your potion ingredients or attempt scores. Only you can decrypt your private data (with your signature), and only publicly marked data (best scores) can be seen by others. This is cryptographically enforced, not just access control."
        },
        {
          "type": "subheader",
          "text": "Part 1: Initializing the FHE SDK"
        },
        {
          "type": "text",
          "content": "The FHE SDK must be initialized before any encryption operations. We'll create initialization functions and a loading screen to ensure the SDK is ready before users interact with your dApp."
        },
        {
          "type": "text",
          "content": "**File: `src/lib/fhe.ts` - SDK Initialization**"
        },
        {
          "type": "text",
          "content": "Find the empty `initializeFHE` and `getFhevmInstance` functions. Replace them with this implementation:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Initializing the FHE SDK",
          "code": "export async function initializeFHE() {\n  try {\n    if (!relayer) {\n      await initSDK();\n      relayer = await createInstance(SepoliaConfig);\n    }\n    return relayer;\n  } catch (error) {\n    console.error(\"Failed to initialize FHEVM relayer SDK:\", error);\n    throw new Error(\"Failed to initialize FHE encryption\");\n  }\n}\n\nexport async function getFhevmInstance() {\n  if (!relayer) {\n    await initializeFHE();\n  }\n  return relayer;\n}"
        },
        {
          "type": "note",
          "icon": "rocket",
          "title": "What Happens During Initialization",
          "content": "**initSDK()**: Loads the core FHE cryptographic libraries (WASM modules for encryption/decryption). Takes 2-3 seconds. **createInstance(SepoliaConfig)**: Configures the relayer service for Zama's Sepolia deployment, setting up the gateway for encryption and decryption operations. **relayer singleton**: Stored globally so we only initialize once. Subsequent calls return the existing instance."
        },
        {
          "type": "text",
          "content": "**File: `src/App.tsx` - Loading Screen**"
        },
        {
          "type": "text",
          "content": "Go to your App.tsx, and at the top of your App function, paste this code so we can use the initializeFHE globally"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "App Component with FHE Initialization",
          "code": "const App = () => {\n  const [fheReady, setFheReady] = useState(false);\n\n  useEffect(() => {\n    initializeFHE()\n      .then(() => {\n        console.log(\"FHE initialized successfully\");\n        setFheReady(true);\n      })\n      .catch((err) => {\n        console.error(\"Failed to initialize FHE:\", err);\n      });\n  }, []);\n\n  if (!fheReady) {\n    return (\n      <div className=\"min-h-screen bg-background flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-magic-purple mx-auto mb-4\"></div>\n          <p className=\"text-muted-foreground\">Initializing encryption...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (/* ... rest of your app UI */);\n};"
        },
        {
          "type": "note",
          "icon": "hourglass",
          "title": "Why the Loading Screen?",
          "content": "If users try to encrypt data before the SDK is ready, they'll get 'relayer not initialized' errors. The loading screen prevents this by blocking the UI until `fheReady` is true. The spinning animation and message provide feedback during the 2-3 second initialization. Once loaded, all FHE operations work immediately."
        },
        {
          "type": "tip",
          "icon": "check-circle",
          "title": "Testing Initialization",
          "content": "After implementing this, refresh your app. You should see the loading screen briefly, then the main UI appears. Check the browser console - you should see 'FHE initialized successfully'. If initialization fails, check your network connection (the SDK needs to load WASM modules from a CDN)."
        },
        {
          "type": "subheader",
          "text": "Part 2: Client-Side Encryption"
        },
        {
          "type": "text",
          "content": "Now let's encrypt user input! When a user selects 5 potions and clicks 'Brew', we need to encrypt those values locally before sending them to the blockchain. This ensures no plaintext ever leaves the browser."
        },
        {
          "type": "text",
          "content": "**File: `src/lib/fhe.ts` - Encryption Function**"
        },
        {
          "type": "text",
          "content": "Find the empty `encryptValue` function and implement it:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Encrypting Potion Ingredients",
          "code": "export async function encryptValue(\n  contractAddress: string,\n  address: string,\n  plainDigits: number[]\n) {\n  if (!relayer) throw new Error(\"Relayer not initialized\");\n\n  const inputHandle = relayer.createEncryptedInput(contractAddress, address);\n  \n  for (const d of plainDigits) {\n    inputHandle.add8(d);\n  }\n  \n  const ciphertextBlob = await inputHandle.encrypt();\n  return ciphertextBlob;\n}"
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "How Encryption Works",
          "content": "**createEncryptedInput()**: Creates a builder bound to your contract address and user's wallet. This context is cryptographically important. **add8()**: Adds each ingredient as an encrypted uint8 (range 0-255), matching your contract's `externalEuint8` parameters. Called 5 times for 5 ingredients. **encrypt()**: Performs the actual FHE encryption, returning an object with `handles` (encrypted ciphertext pointers) and `inputProof` (attestation proving validity)."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "What's in the Ciphertext Blob?",
          "content": "The returned object contains: **handles[]**: Array of 5 encrypted values (one per ingredient). Each is a unique ciphertext handle. **inputProof**: Cryptographic proof that these ciphertexts were properly generated and haven't been tampered with. Your contract will verify this proof via `FHE.fromExternal()` to prevent malicious inputs."
        },
        {
          "type": "subheader",
          "text": "Part 3: Submitting Encrypted Transactions"
        },
        {
          "type": "text",
          "content": "With encryption ready, let's implement the full transaction submission flow. This is the most complex function - it encrypts data, formats it for the contract, submits the transaction, waits for confirmation, and extracts the result from event logs."
        },
        {
          "type": "text",
          "content": "**File: `src/hooks/usePotionContract.ts` - submitPotion Function**"
        },
        {
          "type": "text",
          "content": "Find the `submitPotion` function with mock implementation and replace it entirely:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Complete Transaction Submission (Part 1)",
          "code": "const submitPotion = useCallback(async (vaultCode: number[]) => {\n  if (!address || !walletClient || !publicClient) {\n    throw new Error(\"Wallet not connected\");\n  }\n  \n  try {\n    setIsLoading(true);\n\n    // STEP 1: Encrypt ingredients client-side\n    const encryptedVault = await encryptValue(\n      contractConfig.address,\n      address,\n      vaultCode\n    );\n\n    toast({\n      title: \"⚡ Encrypting potion...\",\n      description: \"Securing your brew with FHE encryption.\",\n    });\n\n    // STEP 2: Format encrypted handles as hex strings\n    const formatHandle = (handle: any): `0x${string}` => {\n      if (typeof handle === 'string') {\n        return handle.startsWith('0x') ? handle as `0x${string}` : `0x${handle}`;\n      }\n      const hexString = Array.from(new Uint8Array(handle))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      return `0x${hexString}`;\n    };"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Complete Transaction Submission (Part 2)",
          "code": "    // STEP 3: Submit transaction to blockchain\n    const hash = await walletClient.writeContract({\n      address: contractConfig.address,\n      abi: contractConfig.abi,\n      functionName: \"compute\",\n      args: [\n        formatHandle(encryptedVault.handles[0]),\n        formatHandle(encryptedVault.handles[1]),\n        formatHandle(encryptedVault.handles[2]),\n        formatHandle(encryptedVault.handles[3]),\n        formatHandle(encryptedVault.handles[4]),\n        formatHandle(encryptedVault.inputProof),\n      ],\n      account: address,\n    } as any);\n\n    toast({\n      title: \"📡 Transaction submitted\",\n      description: \"Waiting for confirmation...\",\n    });\n\n    // STEP 4: Wait for transaction to be mined\n    const receipt = await publicClient.waitForTransactionReceipt({ hash });"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Complete Transaction Submission (Part 3)",
          "code": "    // STEP 5: Decode ComputeResult event from logs\n    let value: string | null = null;\n    \n    for (const log of receipt.logs ?? []) {\n      try {\n        const decoded: any = decodeEventLog({\n          abi: contractConfig.abi,\n          data: log.data,\n          topics: (log as any).topics,\n        });\n        \n        if (decoded.eventName === \"ComputeResult\") {\n          value = decoded.args.value;\n          break;\n        }\n      } catch {\n        continue;\n      }\n    }\n\n    if (value == null) {\n      throw new Error(\"ComputeResult not found in logs\");\n    }\n\n    // STEP 6: Decrypt result with user's private key\n    const provider = new ethers.BrowserProvider(walletClient.transport as any);\n    const signer = await provider.getSigner();\n\n    const decrypted = await requestUserDecryption(\n      contractConfig.address,\n      signer,\n      value\n    );\n\n    return { decrypted };"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Complete Transaction Submission (Part 4 - Error Handling)",
          "code": "  } catch (err: any) {\n    const errorMsg = err.message || \"\";\n    if (errorMsg.includes(\"rejected\") || errorMsg.includes(\"denied\")) {\n      toast({\n        title: \"❌ Transaction Cancelled\",\n        description: \"You rejected the transaction.\",\n        variant: \"destructive\",\n      });\n    } else {\n      toast({\n        title: \"❌ Transaction Failed\",\n        description: \"Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}, [address, walletClient, publicClient, toast]);"
        },
        {
          "type": "note",
          "icon": "zap",
          "title": "Breaking Down the Transaction Flow",
          "content": "**Step 1**: Encrypt 5 ingredients using `encryptValue()` from Part 2. **Step 2**: Convert handles to hex format that Viem/contract expects. **Step 3**: Submit via `writeContract()` - MetaMask pops up for user approval. **Step 4**: Wait for blockchain confirmation (15-30 seconds). **Step 5**: Parse transaction logs to extract the encrypted result event. **Step 6**: Decrypt the result so user can see their score."
        },
        {
          "type": "note",
          "icon": "file-code",
          "title": "Why Format Handles?",
          "content": "The FHE SDK returns handles as various types (Uint8Array, strings, etc.). Your smart contract expects `bytes calldata` which Viem needs as hex strings with '0x' prefix. The `formatHandle` helper converts any format to proper hex. Without this, the contract would reject the transaction with 'invalid input' errors."
        },
        {
          "type": "note",
          "icon": "file-text",
          "title": "Event Log Decoding Explained",
          "content": "When your contract emits `ComputeResult(value)`, the encrypted result is buried in the transaction receipt's logs. We loop through all logs, decode each with your contract's ABI, and extract `value` when we find the ComputeResult event. This encrypted `euint16` handle is what we decrypt in Step 6. The try-catch is necessary because other contracts might emit logs in the same transaction."
        },
        {
          "type": "tip",
          "icon": "lightbulb",
          "title": "Progressive User Feedback",
          "content": "Notice the toast messages guide users through each step: '⚡ Encrypting' → '📡 Transaction submitted' → (waiting) → Success. This 15-30 second process feels transparent rather than frozen. Users know exactly what's happening, reducing anxiety and abandoned transactions."
        },
        {
          "type": "subheader",
          "text": "Part 4: Private Decryption with EIP-712 Signatures"
        },
        {
          "type": "text",
          "content": "The encrypted result from your contract can only be decrypted by you. This requires proving ownership through an EIP-712 signature. Let's implement the private decryption function that prompts users to sign and then decrypts their personal data."
        },
        {
          "type": "text",
          "content": "**File: `src/lib/fhe.ts` - Private Decryption**"
        },
        {
          "type": "text",
          "content": "Find the empty `requestUserDecryption` function and implement it:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "EIP-712 Signature-Based Decryption (Part 1)",
          "code": "export async function requestUserDecryption(\n  contractAddress: string,\n  signer: Signer,\n  ciphertextHandle: string\n) {\n  if (!relayer) throw new Error(\"Relayer not initialized\");\n\n  // 1. Generate ephemeral keypair for this request\n  const keypair = relayer.generateKeypair();\n  \n  // 2. Setup decryption parameters\n  const handleContractPairs: HandleContractPair[] = [\n    { handle: ciphertextHandle, contractAddress }\n  ];\n  const startTimeStamp = Math.floor(Date.now() / 1000).toString();\n  const durationDays = \"10\";\n  const contractAddresses = [contractAddress];"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "EIP-712 Signature-Based Decryption (Part 2)",
          "code": "  // 3. Create EIP-712 typed data structure\n  const eip712 = relayer.createEIP712(\n    keypair.publicKey,\n    contractAddresses,\n    startTimeStamp,\n    durationDays\n  );\n\n  // 4. Request user signature (MetaMask popup)\n  const signature = await signer.signTypedData(\n    eip712.domain,\n    { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification },\n    eip712.message\n  );"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "EIP-712 Signature-Based Decryption (Part 3)",
          "code": "  // 5. Decrypt with relayer using signature proof\n  const result = await relayer.userDecrypt(\n    handleContractPairs,\n    keypair.privateKey,\n    keypair.publicKey,\n    signature.replace(\"0x\", \"\"),\n    contractAddresses,\n    await signer.getAddress(),\n    startTimeStamp,\n    durationDays\n  );\n\n  return result[ciphertextHandle];\n}"
        },
        {
          "type": "note",
          "icon": "key",
          "title": "Understanding EIP-712 Signatures",
          "content": "**What is EIP-712?** A standard for signing typed, structured data (not transactions). No gas cost. **Why sign?** The relayer needs cryptographic proof that YOU authorize decryption of YOUR encrypted data. Anyone can see the encrypted handle onchain, but only you can prove ownership to decrypt it. **What you're signing**: 'I (wallet address) authorize decryption of this ciphertext handle for 10 days using this public key.'"
        },
        {
          "type": "note",
          "icon": "shield",
          "title": "Security: How It Works",
          "content": "**generateKeypair()**: Creates ephemeral keys (not your wallet keys) for this specific decryption request. **Signature verification**: The relayer checks: (1) Signature is valid for your wallet address, (2) You're authorized to decrypt this handle, (3) Request hasn't expired. Only then does it decrypt and return plaintext. Without valid signature, decryption fails - this is the cryptographic privacy guarantee."
        },
        {
          "type": "note",
          "icon": "clock",
          "title": "Duration Parameter",
          "content": "`durationDays: '10'` means this authorization is valid for 10 days. After that, you'd need to sign again to decrypt the same data. This limits the window for potential key compromise. For this game, 10 days is plenty - results are immediate. Production apps might use shorter durations (hours) for sensitive data."
        },
        {
          "type": "tip",
          "icon": "user-check",
          "title": "User Experience",
          "content": "When this function runs, MetaMask shows a signature popup (not a transaction popup). Users see the structured data they're signing. Make sure your app UI explains: 'Sign to decrypt your score (no gas fee)'. First-time users might be confused since it looks different from transaction approvals."
        },
        {
          "type": "subheader",
          "text": "Part 5: Public Decryption for Leaderboards"
        },
        {
          "type": "text",
          "content": "While personal scores require signatures, leaderboard scores are marked as publicly decryptable by your contract. Anyone can request decryption of these values without signing. Let's implement the public decryption function."
        },
        {
          "type": "text",
          "content": "**File: `src/lib/fhe.ts` - Public Decryption**"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Public Decryption Function",
          "code": "export async function fetchPublicDecryption(handles: string[]): Promise<any> {\n  if (!relayer) throw new Error(\"Relayer not initialized\");\n  return relayer.publicDecrypt(handles);\n}"
        },
        {
          "type": "note",
          "icon": "users",
          "title": "Public vs Private Decryption",
          "content": "**publicDecrypt()**: No signature required because the contract called `FHE.makePubliclyDecryptable()` on these handles. The relayer knows these are public and allows anyone to decrypt them. **Use case**: Leaderboard best scores need transparency for competition. **Privacy preserved**: Individual potion ingredients and attempt scores remain private (require signature). Only the best scores become public."
        },
        {
          "type": "text",
          "content": "**Update Leaderboard Fetching (`src/hooks/usePotionContract.ts`)**"
        },
        {
          "type": "text",
          "content": "Now that we have public decryption, update your `fetchLeaderboard` function to decrypt the scores:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "Complete Leaderboard with Decryption",
          "code": "const fetchLeaderboard = useCallback(async () => {\n  if (!publicClient) return [];\n  \n  try {\n    setIsLoading(true);\n\n    const result = await publicClient.readContract({\n      address: contractConfig.address,\n      abi: contractConfig.abi,\n      functionName: \"getAllHighestGuesses\",\n      args: [],\n    } as any);\n\n    const [players, guesses] = result as [string[], string[]];\n\n    if (guesses.length === 0) return [];\n\n    // Decrypt the encrypted scores publicly\n    const decryptedMap = await fetchPublicDecryption(guesses);\n    \n    // Map players to their decrypted scores\n    return players.map((player, idx) => ({\n      player,\n      guess: Number(decryptedMap[guesses[idx]]),\n    }));\n  } catch (err: any) {\n    console.error(\"Error fetching leaderboard:\", err);\n    toast({\n      title: \"Failed to load leaderboard\",\n      description: \"Unable to fetch leaderboard data.\",\n      variant: \"destructive\",\n    });\n    return [];\n  } finally {\n    setIsLoading(false);\n  }\n}, [publicClient, toast]);"
        },
        {
          "type": "note",
          "icon": "book-open",
          "title": "How This Works",
          "content": "`fetchPublicDecryption(guesses)` takes an array of encrypted handles and returns a map: `{ '0x123...': 450, '0x456...': 720 }`. We use this map to convert each encrypted handle to its plaintext number. `Number()` converts the decrypted value to a JavaScript number for display. The leaderboard now shows actual scores instead of encrypted handles!"
        },
        {
          "type": "tip",
          "icon": "check-circle",
          "title": "Testing Leaderboard Decryption",
          "content": "After implementing this, your leaderboard should display actual numbers! If you haven't played yet, submit a potion brew first. Wait for the transaction to confirm, then refresh the leaderboard. You should see your wallet address and your best score in plaintext. If you see '[object Object]' or encrypted strings, check that you're calling `Number()` on the decrypted value."
        },
        {
          "type": "subheader",
          "text": "Complete Testing Checklist"
        },
        {
          "type": "text",
          "content": "Time to test your complete encrypted dApp! Follow this comprehensive checklist:"
        },
        {
          "type": "list",
          "items": [
            "**✅ FHE Initialization**: App shows loading screen briefly, then loads. Console logs 'FHE initialized successfully'.",
            "**✅ Wallet Connection**: Connect MetaMask, see formatted address and balance.",
            "**✅ Leaderboard Loading**: Leaderboard displays (may be empty) with no console errors.",
            "**✅ Potion Selection**: Click 5 potion bottles, 'Brew Potion' button enables.",
            "**✅ Encryption Toast**: Click 'Brew Potion', see '⚡ Encrypting potion...' toast.",
            "**✅ Transaction Approval**: MetaMask pops up requesting transaction approval.",
            "**✅ Transaction Submission**: After approval, see '📡 Transaction submitted' toast.",
            "**✅ Signature Request**: MetaMask pops up requesting signature (EIP-712, not transaction).",
            "**✅ Result Display**: After confirmation, see your decrypted score with success message.",
            "**✅ Leaderboard Update**: Refresh leaderboard, see your address and score in plaintext.",
            "**✅ Cancellation Handling**: Try brewing but reject transaction - see cancellation message, no errors.",
            "**✅ Signature Cancellation**: Approve transaction but reject signature - handled gracefully."
          ]
        },
        {
          "type": "tip",
          "icon": "bug",
          "title": "Common Issues & Solutions",
          "content": "**'Relayer not initialized'**: Refresh page, ensure loading screen completes. **'Invalid handle format'**: Check `formatHandle` function is implemented correctly. **'Signature verification failed'**: Try disconnecting/reconnecting wallet, clear MetaMask cache. **Leaderboard shows '[object Object]'**: Ensure you're calling `Number()` on decrypted values. **Transaction succeeds but no result**: Check event name matches exactly: 'ComputeResult'."
        },
        {
          "type": "subheader",
          "text": "Understanding the Complete Flow"
        },
        {
          "type": "text",
          "content": "Let's trace a complete user journey through your encrypted dApp:"
        },
        {
          "type": "list",
          "items": [
            "**1. App Load**: FHE SDK initializes (2-3s), loads cryptographic libraries, configures relayer.",
            "**2. Wallet Connect**: User connects MetaMask, app displays address/balance via Wagmi hooks.",
            "**3. View Leaderboard**: App calls `getAllHighestGuesses` → Gets encrypted handles → Publicly decrypts → Displays scores.",
            "**4. Select Potions**: User clicks 5 bottles, state updates, button enables.",
            "**5. Encryption**: `encryptValue` encrypts 5 numbers locally → Returns handles + proof.",
            "**6. Transaction**: `writeContract` sends encrypted data to blockchain → MetaMask approval → Transaction hash.",
            "**7. Confirmation**: Wait for mining → Parse logs → Extract encrypted result handle.",
            "**8. Private Decryption**: Generate keypair → Create EIP-712 → User signs → Relayer decrypts → Return plaintext.",
            "**9. Display**: Show score to user, update leaderboard.",
            "**10. Privacy Achieved**: Ingredients never left browser unencrypted. Blockchain never saw plaintext. Only user decrypted their result."
          ]
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "The Privacy Guarantee",
          "content": "At no point in this flow does anyone except the user see the plaintext ingredient values or attempt scores. The blockchain stores only ciphertexts. Validators process encrypted transactions. Block explorers show encrypted data. Only authorized decryption (with signature) reveals plaintext. Best scores become public only after being marked as such by the contract. This is cryptographically enforced privacy on a public blockchain!"
        },
        {
          "type": "subheader",
          "text": "Real-World Applications of FHE"
        },
        {
          "type": "text",
          "content": "The patterns you've learned extend far beyond games. Here are production use cases:"
        },
        {
          "type": "list",
          "items": [
            "**Private Voting**: Encrypted votes, homomorphic tallying, public results without revealing individual choices.",
            "**Sealed-Bid Auctions**: Bids stay encrypted during auction, only winner revealed after closing.",
            "**Confidential DeFi**: Trading with encrypted balances/amounts, protecting position sizes from MEV.",
            "**Healthcare Records**: Encrypted medical data onchain, selective disclosure to authorized providers.",
            "**Supply Chain**: Proprietary quantities/prices encrypted, revealed only to parties in transaction.",
            "**Credit Scoring**: Encrypted financial data processed for scores without exposing underlying info.",
            "**Private DAOs**: Encrypted proposal details until voting completes, preventing manipulation.",
            "**Payroll Systems**: Encrypted salary data, individuals decrypt their own, aggregate statistics public."
          ]
        },
        {
          "type": "note",
          "icon": "trending-up",
          "title": "Why FHE Matters",
          "content": "Traditional blockchain forces a choice: transparency OR privacy. FHE breaks this tradeoff. You get: (1) Verifiable computation (blockchain guarantees), (2) Data privacy (encryption), (3) Selective disclosure (choose what to reveal), (4) Trustless operation (no trusted third party). This enables entirely new categories of blockchain applications impossible with public ledgers."
        },
        {
          "type": "subheader",
          "text": "Performance Considerations & Optimization"
        },
        {
          "type": "list",
          "items": [
            "**Gas Costs**: FHE operations are expensive (10-100x normal operations). Use smallest encrypted types possible (`euint8` vs `euint32`).",
            "**Initialization Time**: SDK loads WASM (~2-3s). Show loading screens, don't block user interactions unnecessarily.",
            "**Encryption Speed**: Client-side encryption is fast (<1s for 5 values). Parallelize if encrypting many values.",
            "**Decryption Latency**: Relayer requests take 2-5s. Show progress indicators, don't assume instant responses.",
            "**Transaction Confirmation**: Encrypted transactions still follow normal block times (15-30s on Sepolia).",
            "**Batch Operations**: If submitting multiple potions, consider batching contract calls to save gas.",
            "**Caching**: Cache public decryptions - they don't change. Don't re-decrypt leaderboard on every view.",
            "**Error Retry**: Network issues are common in Web3. Implement exponential backoff for failed requests."
          ]
        },
        {
          "type": "tip",
          "icon": "zap",
          "title": "Production Optimization Tips",
          "content": "**Lazy load FHE SDK**: Initialize only when user clicks 'Brew' first time (not on app load) if most users just view leaderboard. **Service worker**: Cache WASM modules for instant subsequent loads. **Optimistic UI**: Show 'submitting' state immediately, update after confirmation. **Request batching**: If decrypting many leaderboard entries, batch them into single relayer request."
        },
        {
          "type": "subheader",
          "text": "Next Steps & Advanced Topics"
        },
        {
          "type": "text",
          "content": "You've built a complete privacy-preserving dApp! Here are directions to expand your skills:"
        },
        {
          "type": "list",
          "items": [
            "**Add More FHE Operations**: Experiment with `FHE.min`, `FHE.max`, `FHE.div` in your contract for different game mechanics.",
            "**Implement Time-Based Reveals**: Use block timestamps to auto-reveal scores after a delay.",
            "**Build Multiplayer Features**: Add encrypted head-to-head comparisons without revealing individual scores.",
            "**Add Access Control**: Implement role-based decryption permissions (admin can see all scores).",
            "**Create Leaderboard Filters**: Sort by score, filter by date, search by player.",
            "**Deploy to Mainnet**: When Zama launches mainnet, migrate with real economic value.",
            "**Build Analytics Dashboard**: Aggregate public data for insights (total games, average scores, etc.).",
            "**Add Social Features**: Share achievements, challenge friends, create tournaments."
          ]
        },
        {
          "type": "tip",
          "icon": "book-open",
          "title": "Continue Learning",
          "content": "**Zama Documentation**: Deep dive into advanced FHE operations and optimization techniques. **EIP-712 Spec**: Understand structured data signing for custom authorization flows. **Viem Advanced**: Learn about contract events, multicall, and batch operations. **Web3 Security**: Study common vulnerabilities (reentrancy, access control, oracle attacks). **Gas Optimization**: Techniques for reducing transaction costs in production."
        },
        {
          "type": "subheader",
          "text": "Congratulations!"
        },
        {
          "type": "text",
          "content": "You've mastered building privacy-preserving Web3 applications with Fully Homomorphic Encryption! You can now:"
        },
        {
          "type": "list",
          "items": [
            "Deploy FHE-enabled smart contracts to Sepolia testnet",
            "Initialize and configure the Zama FHE SDK in React applications",
            "Encrypt sensitive data client-side before blockchain submission",
            "Submit and confirm encrypted transactions with proper error handling",
            "Implement EIP-712 signature-based private decryption",
            "Decrypt public data for leaderboards and shared information",
            "Build production-ready user experiences with loading states and feedback",
            "Understand the complete encrypted data lifecycle from input to output"
          ]
        },
        {
          "type": "text",
          "content": "This technology is cutting-edge - you're among the first developers building truly private blockchain applications. The patterns you've learned here apply to countless real-world use cases where privacy is paramount. Keep experimenting, keep building, and help shape the future of confidential smart contracts!"
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "You're a Privacy Pioneer",
          "content": "FHE on blockchain is nascent technology. By building this dApp, you've gained expertise that few developers have. The Web3 industry desperately needs privacy solutions for mass adoption. You now have the skills to build them. Consider contributing to open source FHE projects, writing tutorials, or building production applications. The future of private smart contracts starts with pioneers like you!"
        }
      ],
      "resources": [
        {
          "title": "Zama Docs",
          "url": "https://docs.zama.ai/"
        },
        {
          "title": "EIP-712 Specification",
          "url": "https://eips.ethereum.org/EIPS/eip-712"
        },
        {
          "title": "Web3 Security Best Practices",
          "url": "https://ethereum.org/en/developers/docs/security/"
        },
        {
          "title": "Sepolia Etherscan",
          "url": "https://sepolia.etherscan.io/"
        }
      ]
    },
    {
      "id": 9,
      "title": "Reflecting on the Brew",
      "subtitle": "Recap, Achievements, and Lessons Learned",
      "description": "Well done, master brewers – your confidential potion is bubbling! Let's pause to reflect on the journey through our Private Potion Brewer dApp. This section recaps the full process in clear steps, celebrates your key achievements, and distills the core lessons on fhEVM's privacy magic. Think of it as tasting your elixir: Savor what you've created, note the flavors (learnings), and ponder how to refine future brews.",
      "learningObjectives": [
        "Recap the end-to-end dApp development process, from FHE basics to frontend integration",
        "Recognize your achievements in building a privacy-focused application",
        "Identify key lessons on fhEVM's strengths, challenges, and real-world applications"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Run-Through: The Complete Brewing Process"
        },
        {
          "type": "text",
          "content": "Here's a step-by-step recap of our adventure, like reviewing a spellbook after a successful incantation:"
        },
        {
          "type": "list",
          "items": [
            "**FHE and fhEVM Foundations (Sections 1-2)**: We unveiled FHE's principles – computing on encrypted data without decryption – and explored fhEVM as Zama's EVM extension for onchain privacy. You learned crypto basics (keys, TFHE scheme), data types (euint8, ebool), and operations (add, eq) with examples.",
            "**Project Setup and Tools (Sections 3-5)**: We outlined the dApp (private brewing game), gathered tools (Hardhat, React, relayer-sdk, Wagmi), cloned the boilerplate repo, and configured environments – adding Sepolia to MetaMask, funding with faucets, and setting env vars for secure deploys.",
            "**Contract Crafting (Section 6)**: Built PotionBrew.sol with encrypted target storage and private comparisons using TFHE.eq, testing via Hardhat to verify privacy.",
            "**Deployment and Integration (Section 7)**: Deployed to Sepolia with scripts/deploy.ts, added ABI to frontend, and integrated Wagmi/RainbowKit in App.tsx for wallet connects and contract writes.",
            "**Encryption Magic (Section 8)**: Added relayer-sdk in lib/fhe.ts for init/encrypt/decrypt and handling client-side privacy "
          ]
        },
        {
          "type": "note",
          "icon": "trophy",
          "title": "The Result",
          "content": "A full dApp where users encrypt guesses, the contract computes privately, and only the caller decrypts the outcome – all on Sepolia for real blockchain feel!"
        },
        {
          "type": "subheader",
          "text": "Achievements: What You've Mastered"
        },
        {
          "type": "text",
          "content": "Give yourself a pat on the back – here's what you've accomplished:"
        },
        {
          "type": "list",
          "items": [
            "**Built a Confidential dApp from Scratch**: Deployed a privacy-preserving guessing game, demonstrating the encrypt-compute-decrypt workflow end-to-end",
            "**Integrated Key Tools Seamlessly**: Combined Hardhat for backend, React/Next.js for UI, Wagmi for interactions, and relayer sdk for FHE – a full-stack Web3 skillset",
            "**Ensured True Privacy**: No data leaks; everything stays encrypted onchain, with offchain decryption for users only",
            "**Tested and Optimized**: Used Hardhat tests to validate logic, aware of gas costs and optimizations"
          ]
        },
        {
          "type": "tip",
          "icon": "star",
          "title": "Level Up",
          "content": "These skills position you to tackle advanced apps, like private voting or confidential auctions. You're now part of the privacy-first Web3 movement!"
        },
        {
          "type": "subheader",
          "text": "Lessons Learned: Insights from the Cauldron"
        },
        {
          "type": "list",
          "items": [
            "**Privacy Without Compromise**: fhEVM solves Web3's transparency-privacy tension – computations are verifiable yet secret, ideal for DeFi, health data, or AI inference",
            "**Broader Impact**: This project shows FHE's potential in real dApps – e.g., sealed-bid auctions where bids compute privately, or machine learning on encrypted inputs",
            "**Best Practices**: Always test locally/Sepolia first; use .env for secrets; modularize with hooks for clean code"
          ]
        },
        {
          "type": "note",
          "icon": "lightbulb",
          "title": "Reflection Exercise",
          "content": "How might you adapt this for a multiplayer version? What other privacy problems could you solve with FHE? Experiment to solidify your knowledge!"
        },
        {
          "type": "subheader",
          "text": "Real-World Applications Beyond Gaming"
        },
        {
          "type": "text",
          "content": "The techniques you've learned apply far beyond guessing games. FHE enables groundbreaking applications:"
        },
        {
          "type": "list",
          "items": [
            "**Private Voting Systems**: Votes encrypted onchain, tallied without revealing individual choices, ensuring democratic integrity",
            "**Confidential DeFi**: Trading, lending, borrowing without exposing positions or wallet balances",
            "**Healthcare on Blockchain**: Medical records stored encrypted, analyzed for insights without compromising patient privacy",
            "**Sealed-Bid Auctions**: Bids remain hidden until reveal time, preventing front-running and manipulation",
            "**Private Gaming**: Game state hidden from players and servers, enabling true fog-of-war mechanics",
            "**Encrypted Machine Learning**: Train models on private datasets without exposing training data"
          ]
        },
        {
          "type": "subheader",
          "text": "Debugging and Troubleshooting Tips"
        },
        {
          "type": "list",
          "items": [
            "**Full App Debug**: Simulate complete workflows locally with Hardhat node before testnet deployment",
            "**Log Encrypted Values**: Display encrypted values as hex strings for verification and debugging",
            "**Gas Estimation**: Use hardhat gas-reporter plugin to identify expensive operations",
            "**Frontend Errors**: Check browser console for relayer sdk initialization and encryption errors",
            "**Contract Events**: Emit events for important state changes to track execution flow"
          ]
        },
        {
          "type": "tip",
          "icon": "terminal",
          "title": "Pro Debugging Tip",
          "content": "Use Etherscan to monitor transactions on Sepolia. You can see the encrypted bytes being passed around, confirming that plaintext values never touch the blockchain!"
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "The workflow – setup, build, deploy, integrate – creates robust private dApps",
            "Achievements include mastering fhEVM tools for encrypted logic",
            "Lessons emphasize optimization, security, and FHE's transformative role in Web3",
            "You're ready to build the next generation of privacy-preserving applications",
            "The encrypt-compute-decrypt pattern is your blueprint for future projects"
          ]
        }
      ],
      "resources": [
        {
          "title": "Zama Protocol overview",
          "url": "https://docs.zama.ai/protocol/examples"
        },
        {
          "title": "Zama solidity guides",
          "url": "https://docs.zama.ai/protocol/examples"
        },
        {
          "title": "Zama Examples",
          "url": "https://docs.zama.ai/protocol/examples"
        }
      ]
    },
    {
      "id": 10,
      "title": "Sharing the Elixir",
      "subtitle": "Deploying Your dApp, Next Steps, and FHEVM Advantages",
      "description": "Your potion is perfected – now bottle it and share with the world! This final section covers deploying the full frontend to Vercel (or similar), suggests extensions, and reiterates fhEVM's standout benefits. It's like distributing your elixir to fellow alchemists: Make it accessible, inspire builds, and highlight why this tech shines.",
      "learningObjectives": [
        "Deploy the React frontend to Vercel for public access",
        "Plan next steps, like extensions and sharing for feedback or bounties",
        "Explain fhEVM's advantages in privacy, security, and Web3 innovation"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Deployment: Bottling for the Masses"
        },
        {
          "type": "text",
          "content": "Host your frontend on Vercel – it's free, fast, and integrates with GitHub."
        },
        {
          "type": "text",
          "content": "**Step 1: Install Vercel CLI**"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Install Vercel CLI",
          "code": "npm i -g vercel"
        },
        {
          "type": "note",
          "icon": "terminal",
          "title": "Global Installation",
          "content": "Installing globally with -g makes the vercel command available throughout your system for easy deployment."
        },
        {
          "type": "text",
          "content": "**Step 2: Configure Environment Variables**"
        },
        {
          "type": "text",
          "content": "In packages/site, create .env.production with CONTRACT_ADDRESS (your deployed PotionBrew.sol address). This ensures the live site points to the right contract."
        },
        {
          "type": "code",
          "language": "bash",
          "title": ".env.production",
          "code": "CONTRACT_ADDRESS=0xYourDeployedAddressHere\nCHAIN_ID=11155111"
        },
        {
          "type": "text",
          "content": "**Step 3: Build and Deploy**"
        },
        {
          "type": "list",
          "items": [
            "Navigate to your frontend folder: cd packages/site",
            "Login to Vercel: vercel login (follow prompts with email/GitHub)",
            "Deploy: vercel --prod",
            "Handle prompts for scope/project name",
            "Vercel builds your Next.js app, uploads, and assigns a URL (e.g., your-app.vercel.app)"
          ]
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Deployment Commands",
          "code": "cd packages/site\nvercel login\nvercel --prod"
        },
        {
          "type": "tip",
          "icon": "rocket",
          "title": "Test After Deploy",
          "content": "Visit your deployed URL, connect MetaMask (Sepolia), submit a guess, and verify decryption works. Check browser console if issues arise."
        },
        {
          "type": "text",
          "content": "**Advanced: GitHub Integration**"
        },
        {
          "type": "text",
          "content": "Link your GitHub repo for automatic deployments on pushes. In Vercel dashboard, connect your repository and enable auto-deploys. Each push to main will trigger a new deployment."
        },
        {
          "type": "note",
          "icon": "github",
          "title": "Custom Domains",
          "content": "For a professional touch, add a custom domain in Vercel settings. Point your DNS to Vercel's servers and your dApp will be live on your own domain!"
        },
        {
          "type": "subheader",
          "text": "Next Steps: Extending and Sharing Your Brew"
        },
        {
          "type": "text",
          "content": "**Enhance the dApp:**"
        },
        {
          "type": "list",
          "items": [
            "**Add Hints**: Use TFHE.gt/lt for 'too high/low' encrypted feedback without revealing the target",
            "**Multiplayer Guesses**: Store multiple encrypted targets for different players, add leaderboards",
            "**Difficulty Levels**: Add ranges (euint16 for 0-65535) or time limits for challenges",
            "**UI Polish**: Add animations with Framer Motion, sound effects, particle effects for correct guesses",
            "**Score Tracking**: Store encrypted score history onchain for persistent records",
            "**NFT Rewards**: Mint NFTs for players who guess correctly within certain attempts"
          ]
        },
        {
          "type": "text",
          "content": "**Share Your Work:**"
        },
        {
          "type": "list",
          "items": [
            "**Push to GitHub**: Fork the boilerplate, add a comprehensive README with demo link, setup instructions, and video walkthrough",
            "**Social Media**: Tweet about your project with #fhEVM #ZamaAI #Web3Privacy hashtags",
            "**Zama Bounties**: Submit to Zama's bounty program if active (check https://www.zama.ai/bounty) – include repo and demo video",
            "**Community Engagement**: Join Zama's Discord/GitHub for feedback and collaboration",
            "**Developer Portfolio**: Showcase this unique privacy-focused project to potential employers or clients"
          ]
        },
        {
          "type": "code",
          "language": "markdown",
          "title": "Sample README.md",
          "code": "# Private Potion Guesser 🧪\n\nA privacy-preserving guessing game powered by fhEVM.\n\n## ✨ Features\n- Fully encrypted guesses and targets\n- Zero-knowledge gameplay\n- Interactive React UI with Wagmi\n- Deployed on Sepolia testnet\n\n## 🛠 Tech Stack\n- **Smart Contracts**: Solidity + fhEVM (Zama)\n- **Frontend**: React + Next.js\n- **Web3**: Wagmi + RainbowKit\n- **Encryption**: Zama relayer sdk\n- **Testing**: Hardhat\n\n## 🚀 Live Demo\n[View Demo](https://your-app.vercel.app)\n\n## 📦 Setup\n1. Clone repo: `git clone ...`\n2. Install: `npm install`\n3. Configure .env with CONTRACT_ADDRESS\n4. Run: `npm run dev`\n\n## 🎮 How to Play\n1. Connect MetaMask (Sepolia)\n2. Enter your guess (0-255)\n3. Encrypt and submit\n4. Decrypt result privately!\n\n## 🔐 Privacy Guarantees\nAll guesses and comparisons happen on encrypted data. The blockchain never sees plaintext values – only you can decrypt your results!"
        },
        {
          "type": "tip",
          "icon": "video",
          "title": "Demo Video",
          "content": "Record a 2-3 minute walkthrough showing: MetaMask connection, encrypting a guess, submitting to contract, and decrypting the result. Use Loom or OBS for easy screen recording."
        },
        {
          "type": "text",
          "content": "**Dive Deeper:**"
        },
        {
          "type": "list",
          "items": [
            "Explore Zama docs for advanced TFHE operations (conditional logic, encrypted comparisons)",
            "Build a private voting dApp as your next project",
            "Try confidential DeFi applications with encrypted balances",
            "Experiment with encrypted machine learning inference"
          ]
        },
        {
          "type": "subheader",
          "text": "fhEVM Advantages: Why This Magic Matters"
        },
        {
          "type": "text",
          "content": "Let's recap why fhEVM stands out in the privacy-tech landscape:"
        },
        {
          "type": "list",
          "items": [
            "**Unmatched Privacy**: Computes on encrypted data onchain – no trusted third parties, unlike some ZK solutions",
            "**Security and Future-Proofing**: Quantum-resistant TFHE using lattice-based cryptography",
            "**Decentralized KMS**: Key management system prevents single-point failures",
            "**Web3 Innovation**: Enables confidential DeFi (private trades), secure AI (encrypted inference), private gaming, and more",
            "**EVM Composability**: Works seamlessly with existing Solidity knowledge and EVM tools",
            "**Ease for Developers**: Familiar syntax with TFHE additions; no complex trusted setups",
            "**Gas Optimizations**: Continuously improving performance makes FHE more practical"
          ]
        },
        {
          "type": "note",
          "icon": "shield",
          "title": "The Privacy Revolution",
          "content": "fhEVM turns blockchain from a public ledger into a private computation engine. You're building the infrastructure for a privacy-first Web3 future!"
        },
        {
          "type": "subheader",
          "text": "Bounty Program and Recognition"
        },
        {
          "type": "text",
          "content": "Zama occasionally runs bounty programs for innovative fhEVM applications. Here's how to stand out:"
        },
        {
          "type": "list",
          "items": [
            "Polish your repository with clear documentation and code comments",
            "Create a professional demo video (2-3 minutes) showing the dApp in action",
            "Explain the privacy guarantees and why FHE was necessary for your use case",
            "Document challenges faced and how you solved them",
            "Highlight innovative use of TFHE operations",
            "Include comprehensive tests and security considerations"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Deployment Pitfalls"
        },
        {
          "type": "list",
          "items": [
            "**Environment Variables**: Set all required vars in Vercel dashboard (Project Settings → Environment Variables), not just in .env",
            "**CORS Errors**: Add proper headers in next.config.js if making API calls",
            "**Contract Address**: Always update to production contract address before deploying",
            "**Network Mismatch**: Verify frontend connects to correct chain in Wagmi config",
            "**Build Errors**: Test local build (npm run build) before deploying to catch issues early"
          ]
        },
        {
          "type": "tip",
          "icon": "git-branch",
          "title": "Preview Deployments",
          "content": "Use Vercel preview deployments for testing. Each git branch gets its own preview URL for safe experimentation before production."
        },
        {
          "type": "subheader",
          "text": "Join the Privacy-First Movement"
        },
        {
          "type": "text",
          "content": "The fhEVM ecosystem is rapidly growing. Stay connected and keep building:"
        },
        {
          "type": "list",
          "items": [
            "Join Zama's Discord for latest updates, community support, and collaboration",
            "Follow Zama on Twitter/X for announcements and new features",
            "Explore advanced tutorials for DeFi, gaming, and identity applications",
            "Contribute to open-source fhEVM libraries and tools",
            "Attend Web3 conferences and hackathons focusing on privacy",
            "Share your knowledge through blog posts and tutorials"
          ]
        },
        {
          "type": "note",
          "icon": "heart",
          "title": "Final Congratulations",
          "content": "You've completed an incredible journey from FHE basics to a deployed privacy-preserving dApp! The skills you've gained are foundational for the next generation of blockchain applications. Privacy is not just a feature; it's a fundamental right that you can now protect through fhEVM. Keep building, keep experimenting, and keep the magic of privacy alive in your code!"
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Vercel deployment makes your dApp globally accessible with minimal effort",
            "Extensions and sharing foster growth and community engagement",
            "fhEVM's privacy advantages unlock secure, innovative Web3 applications",
            "You're now equipped to build the future of privacy-first blockchain",
            "The encrypt-compute-decrypt pattern is your superpower for confidential dApps"
          ]
        }
      ],
      "resources": [
        {
          "title": "Vercel Documentation",
          "url": "https://vercel.com/docs"
        },
        {
          "title": "Zama Community Discord",
          "url": "https://discord.com/invite/fhe-org"
        },
        {
          "title": "Zama Bounty Programs",
          "url": "https://www.zama.ai/bounties"
        },
        {
          "title": "fhEVM Use Cases",
          "url": "https://www.zama.ai/use-cases"
        },
        {
          "title": "Advanced fhEVM Tutorials",
          "url": "https://docs.zama.ai/fhevm/tutorials"
        }
      ]
    }
  ],
  "quizzes": [
    {
      "sectionId": 1,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What does 'homomorphic' mean in the context of FHE?",
          "options": [
            "Computing on decrypted data",
            "Preserving operations between plaintext and ciphertext",
            "Randomizing data for security",
            "Compressing files magically"
          ],
          "correctAnswer": 1,
          "explanation": "Homomorphic comes from Greek meaning 'same shape.' It means operations on ciphertexts mirror those on plaintexts, preserving the structure of computations."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "FHE allows __________ on ciphertexts without ever needing to decrypt during the process.",
          "correctAnswer": "computations",
          "alternatives": ["operations", "calculations"],
          "explanation": "FHE enables computations, operations, or calculations on encrypted data without decryption, maintaining privacy throughout."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Which is NOT a real-world application of FHE in blockchain?",
          "options": [
            "Private medical diagnosis",
            "Secure financial analysis",
            "Public transaction broadcasting",
            "Confidential voting systems"
          ],
          "correctAnswer": 2,
          "explanation": "Public transaction broadcasting doesn't require FHE as it's intentionally transparent. FHE is for keeping data private while computing."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "What year did Craig Gentry create the first fully homomorphic encryption scheme?",
          "options": ["1978", "2000", "2009", "2020"],
          "correctAnswer": 2,
          "explanation": "Craig Gentry created the first FHE scheme in 2009 using lattice-based cryptography, turning decades of theory into reality."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "Which type of homomorphic encryption allows unlimited operations?",
          "options": [
            "Partially Homomorphic Encryption (PHE)",
            "Somewhat Homomorphic Encryption (SHE)",
            "Fully Homomorphic Encryption (FHE)",
            "Basic Homomorphic Encryption (BHE)"
          ],
          "correctAnswer": 2,
          "explanation": "FHE allows unlimited combinations of operations (additions, multiplications, etc.) enabling any computation on encrypted data."
        }
      ]
    },
    {
      "sectionId": 2,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What tool is used for frontend encryption in fhEVM?",
          "options": ["Hardhat", "Relayer sdk", "MetaMask", "Wagmi"],
          "correctAnswer": 1,
          "explanation": "Zama relayer sdk is the JavaScript library for client-side encryption and decryption in fhEVM applications."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "To check equality of encrypted values, use: TFHE._____(a, b)",
          "correctAnswer": "eq",
          "explanation": "TFHE.eq performs equality comparison on encrypted values, returning an encrypted boolean (ebool)."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What does 'euint8' represent?",
          "options": [
            "8 ethereum addresses",
            "Encrypted 8-bit unsigned integer",
            "8-byte encryption key",
            "External unit type 8"
          ],
          "correctAnswer": 1,
          "explanation": "euint8 is an encrypted 8-bit unsigned integer type in fhEVM, capable of storing encrypted values from 0-255."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Why use symbolic execution in fhEVM?",
          "options": [
            "To make code look fancy",
            "To handle operations as references, offloading compute for efficiency",
            "To encrypt data automatically",
            "To reduce gas costs to zero"
          ],
          "correctAnswer": 1,
          "explanation": "Symbolic execution handles ciphertext operations as references, offloading heavy computations to coprocessors for blockchain efficiency."
        }
      ]
    },
    {
      "sectionId": 3,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What is the minimum Node.js version required?",
          "options": ["v14", "v16", "v18", "v20"],
          "correctAnswer": 2,
          "explanation": "Node.js v18 or higher is required for the fhEVM development environment and its dependencies."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "Which testnet is recommended for deployment?",
          "options": ["Goerli", "Sepolia", "Rinkeby", "Ropsten"],
          "correctAnswer": 1,
          "explanation": "Sepolia is the recommended Ethereum testnet for fhEVM deployments, offering stability and faucet availability."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "The dApp uses fhEVM for private guesses, showcasing the _____-compute-_____ pattern.",
          "correctAnswer": "encrypt-decrypt",
          "alternatives": ["encrypt, decrypt"],
          "explanation": "The core FHE pattern is encrypt-compute-decrypt: data is encrypted, operations happen on ciphertext, then results are decrypted."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "How does privacy work in the Private Potion Guesser?",
          "options": [
            "Server-side encryption only",
            "Computations on ciphertexts, decrypt offchain",
            "Blockchain hides all data automatically",
            "Using private transactions"
          ],
          "correctAnswer": 1,
          "explanation": "Privacy is achieved through computations on encrypted ciphertexts onchain, with decryption happening offchain by the user."
        }
      ]
    },
    {
      "sectionId": 4,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Which folder contains fhEVM hooks for encryption?",
          "options": [
            "packages/contracts",
            "packages/site/lib/fhe.ts",
            "src/components",
            "lib/encryption"
          ],
          "correctAnswer": 1,
          "explanation": "The packages/site/lib/fhe.ts folder contains essential hooks for encrypting data, fetching public keys, and interacting with fhEVM contracts."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What does the usePotionContract.ts hook show?",
          "options": [
            "Wallet connection",
            "Basic fhEVM operations",
            "UI styling",
            "API calls"
          ],
          "correctAnswer": 1,
          "explanation": "usePotionContract.tsx is a hook showing how to perform basic fhEVM operations like incrementing an encrypted counter using the useFhevm hook."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "Command to clone: git _____ https://github.com/Destiny-01/potion-brew",
          "correctAnswer": "clone",
          "explanation": "The 'git clone' command downloads a copy of the repository to your local machine."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "How does the hooks folder help in our guessing game?",
          "options": [
            "It styles the UI",
            "It provides hooks to encrypt guesses and decrypt results",
            "It connects to the database",
            "It handles wallet connections only"
          ],
          "correctAnswer": 1,
          "explanation": "The hooks folder provides essential hooks to encrypt guesses client-side and decrypt results, maintaining privacy throughout the game."
        }
      ]
    },
    {
      "sectionId": 5,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "Command to deploy Hardhat contracts: npx hardhat _____",
          "correctAnswer": "deploy",
          "explanation": "The 'npx hardhat deploy' command builds your Solidity contracts, and then deploys them"
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What stores sensitive data like MNEMONIC and API keys?",
          "options": [
            "hardhat.config.ts",
            "hardhat vars",
            "package.json",
            "Public GitHub repo"
          ],
          "correctAnswer": 1,
          "explanation": "Environment variables should be stored using 'npx hardhat vars set' for security. Never commit secrets to version control!"
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "To let hardhat use our 12-word phrase, we use npx hardhat vars set _____",
          "correctAnswer": "MNEMONIC",
          "explanation": "The 'npx hardhat vars set MNEMONIC' command lets hardhat use our 12-word phrase"
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Why do we need a faucet?",
          "options": [
            "It's required for production",
            "To get test eth to deploy our contracts",
            "Testnets don't support real money",
            "No reason"
          ],
          "correctAnswer": 1,
          "explanation": "We use the fuacet to get test eth to deploy our contracts to testnets like Sepolia."
        }
      ]
    },
    {
      "sectionId": 6,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What is the critical privacy flaw in the PlainPotion contract shown in the tutorial?",
          "options": [
            "It uses too much gas for computations",
            "All ingredient values and scores are visible in transaction data on the blockchain",
            "It doesn't have enough functions",
            "The contract owner can see all data"
          ],
          "correctAnswer": 1,
          "explanation": "In the PlainPotion contract, all transaction parameters (ingredient values) and computed scores are publicly visible on the blockchain, allowing anyone to reverse-engineer winning strategies by inspecting transaction data."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What does FHE.select(isHigher, result, prevBest) accomplish?",
          "options": [
            "It decrypts the higher value between result and prevBest",
            "It performs an encrypted conditional selection, returning result if isHigher is true, otherwise prevBest",
            "It compares two values and returns a boolean",
            "It selects random values for testing"
          ],
          "correctAnswer": 1,
          "explanation": "FHE.select is an encrypted if/else operation. It takes an encrypted boolean (isHigher) and returns the first value (result) if true, or the second value (prevBest) if false, all without decryption."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What is the purpose of FHE.allow(result, msg.sender) in the compute function?",
          "options": [
            "It allows the contract to modify the result",
            "It grants the player permission to decrypt their own result using their private key",
            "It makes the result publicly visible on the blockchain",
            "It encrypts the result for storage"
          ],
          "correctAnswer": 1,
          "explanation": "FHE.allow grants specific addresses permission to decrypt encrypted values. Without this permission, even the player who submitted the transaction cannot decrypt their own result. It's essential for selective disclosure in fhEVM."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which operation in the contract happens WITHOUT ever decrypting the values?",
          "options": [
            "Only the addition of ingredients",
            "Only the comparison of scores",
            "All operations: addition, multiplication, comparison, and conditional selection",
            "None - values must be decrypted for computation"
          ],
          "correctAnswer": 2,
          "explanation": "This is the power of Fully Homomorphic Encryption! All operations (FHE.add, FHE.mul, FHE.gt, FHE.select) are performed directly on ciphertexts without any decryption. The blockchain never sees plaintext values."
        }
      ]
    },
    {
      "sectionId": 7,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "After deploying your contract with 'yarn deploy:sepolia', what file contains the deployment artifacts you need to copy to your frontend?",
          "options": [
            "hardhat.config.ts",
            "deployments/sepolia/Potion.json",
            "contracts/Potion.sol",
            "artifacts/contracts/Potion.json"
          ],
          "correctAnswer": 1,
          "explanation": "The deployment script saves the contract address and ABI to 'deployments/sepolia/Potion.json'. You copy this entire file to your frontend's config/Potion.json so your app knows where the contract lives and how to interact with it."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "The _____ is like an instruction manual that tells your frontend what functions your contract has and how to call them.",
          "correctAnswer": "ABI",
          "alternatives": ["abi", "Application Binary Interface"],
          "explanation": "ABI (Application Binary Interface) is automatically generated from your Solidity contract during compilation. It describes every function, event, and error with their parameters and types, allowing your frontend to construct properly formatted contract calls."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What do the Wagmi hooks useAccount() and useBalance() provide in your wallet connection component?",
          "options": [
            "They encrypt wallet data before sending to blockchain",
            "They provide the connected wallet's address and ETH balance, updating automatically on changes",
            "They deploy smart contracts from the frontend",
            "They generate new wallet addresses for users"
          ],
          "correctAnswer": 1,
          "explanation": "useAccount() returns wallet connection state including the address, while useBalance() fetches the ETH balance for that address. These hooks are reactive - they automatically re-fetch and update when the user switches accounts or disconnects."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "When reading the leaderboard with publicClient.readContract(), why is this operation free (no gas cost)?",
          "options": [
            "Because we're using a special gas-free API",
            "Because it's a view/pure function that only reads data without modifying blockchain state",
            "Because Sepolia testnet has no gas fees",
            "Because RainbowKit subsidizes the gas costs"
          ],
          "correctAnswer": 1,
          "explanation": "View and pure functions in Solidity don't modify state - they only read existing data. Since they don't require consensus or state changes, they can be executed locally by your node without submitting a transaction, making them free."
        }
      ]
    },
    {
      "sectionId": 8,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Why does your app show a loading screen while the FHE SDK initializes?",
          "options": [
            "To make the app look more professional",
            "To prevent users from encountering 'relayer not initialized' errors if they try to encrypt data before SDK is ready",
            "To load smart contract data from the blockchain",
            "To connect to the user's wallet"
          ],
          "correctAnswer": 1,
          "explanation": "The FHE SDK takes 2-3 seconds to load cryptographic libraries (WASM modules) and configure the relayer. If users try to encrypt data before initialization completes, operations will fail. The loading screen blocks the UI until fheReady is true."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What's the difference between fetchPublicDecryption() and requestUserDecryption()?",
          "options": [
            "There is no difference, they both require signatures",
            "Public decryption works for data marked publicly decryptable by the contract (no signature needed); private decryption requires EIP-712 signature proof",
            "Public decryption is faster but less secure",
            "Private decryption only works on testnet"
          ],
          "correctAnswer": 1,
          "explanation": "publicDecrypt() doesn't require signatures because the contract called FHE.makePubliclyDecryptable() on those handles (like leaderboard best scores). requestUserDecryption() requires EIP-712 signatures to prove ownership before decrypting private data (like individual attempt scores). This enables selective disclosure - you control what becomes public."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "When the contract emits ComputeResult(value), we extract the encrypted result from the transaction receipt's _____ array.",
          "correctAnswer": "logs",
          "alternatives": ["log", "event logs"],
          "explanation": "Contract events are stored in the transaction receipt's logs array. We loop through all logs, decode each with the contract's ABI using decodeEventLog(), and extract the 'value' when we find the ComputeResult event. This encrypted euint16 handle is what we then decrypt to show the user their score."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Why does the tutorial emphasize distinguishing between 'user rejected' and other errors?",
          "options": [
            "To track analytics about rejection rates",
            "Because user rejections aren't failures - they're choices, and shouldn't be treated as errors or make users feel bad",
            "To retry rejected transactions automatically",
            "To charge users for rejected transactions"
          ],
          "correctAnswer": 1,
          "explanation": "Users have the right to reject transactions or signatures - it's a feature, not a bug. Good UX distinguishes rejection (neutral message, no scary red styling) from actual errors (actionable feedback). This respects user agency and doesn't shame them for exercising control over their wallet."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "What's the privacy guarantee of this FHE implementation?",
          "options": [
            "Only the contract owner can see encrypted data",
            "Data is encrypted during transmission but stored in plaintext onchain",
            "Ingredient values and attempt scores never exist in plaintext onchain; only authorized decryption with signature reveals them",
            "Privacy is maintained through access control lists"
          ],
          "correctAnswer": 2,
          "explanation": "With FHE, plaintext never touches the blockchain. Ingredients are encrypted client-side, the contract computes on ciphertexts, results are emitted encrypted. Only cryptographic signatures authorize decryption - the blockchain, validators, and observers see only ciphertexts. This is cryptographically enforced privacy, not just access control."
        }
      ]
    },
    {
      "sectionId": 9,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "The core FHE workflow is: Encrypt, _____, Decrypt",
          "options": ["Deploy", "Compute", "Test", "Verify"],
          "correctAnswer": 1,
          "explanation": "The core FHE workflow is Encrypt-Compute-Decrypt: data is encrypted, computation happens on ciphertext, then results are decrypted."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "You successfully deployed your dApp to _____ testnet.",
          "correctAnswer": "Sepolia",
          "explanation": "Throughout this tutorial, we deployed to the Sepolia Ethereum testnet."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What is FHE's biggest advantage?",
          "options": [
            "Faster transactions",
            "Lower gas costs",
            "Private onchain computations without trust",
            "Simpler code"
          ],
          "correctAnswer": 2,
          "explanation": "FHE's revolutionary advantage is enabling private computations directly on blockchain without requiring trust in any third party."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which skill did you NOT gain in this tutorial?",
          "options": [
            "FHE smart contract development",
            "Client-side encryption/decryption",
            "Machine learning model training",
            "Full-stack dApp deployment"
          ],
          "correctAnswer": 2,
          "explanation": "This tutorial focused on FHE blockchain development, not machine learning. You learned smart contracts, encryption, and deployment."
        }
      ]
    },
    {
      "sectionId": 10,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Does Vercel host smart contracts?",
          "options": [
            "Yes, it hosts everything",
            "No, frontend only",
            "Only Solidity files",
            "Yes, but only on paid plans"
          ],
          "correctAnswer": 1,
          "explanation": "Vercel is a frontend hosting platform. Smart contracts are deployed to blockchain networks separately."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What is a key advantage of fhEVM?",
          "options": [
            "Slower processing",
            "Enhanced data privacy with cryptographic guarantees",
            "Public computation only",
            "Higher gas costs"
          ],
          "correctAnswer": 1,
          "explanation": "fhEVM's key advantage is enhanced data privacy through cryptographic guarantees, enabling trustless confidential computing."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "Command to deploy frontend: _____",
          "correctAnswer": "vercel",
          "explanation": "The 'vercel' command initiates the deployment process to Vercel's platform."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which is a good next step for extending the dApp?",
          "options": [
            "Remove all encryption",
            "Add encrypted hints using FHE.gt/lt comparisons",
            "Make all data public",
            "Delete the contract"
          ],
          "correctAnswer": 1,
          "explanation": "Adding encrypted hints using FHE comparison operations (gt/lt) is a great way to extend the dApp's functionality while maintaining privacy."
        }
      ]
    }
  ]
}
