{
  "sections": [
    {
      "id": 1,
      "title": "Unveiling the Mysteries of FHE",
      "subtitle": "Your First Steps into the Arcane Halls of Data Sorcery",
      "description": "Welcome, aspiring alchemists, to the arcane halls of data sorcery! In this first chamber of our 'Private Potion Brewing Simulator,' we'll lift the veil on Fully Homomorphic Encryption (FHE)—the ultimate spell in the grimoire of privacy. Imagine brewing a potent elixir in a sealed cauldron: you mix enchanted ingredients without ever peeking inside, and only the final potion reveals its power. That's FHE in a nutshell—a magical encryption that lets you perform computations on hidden data, keeping secrets locked away from prying eyes. No more risky revelations during the brewing process! As we embark on this journey with Zama's groundbreaking tools, you'll see how FHE transforms blockchain into a fortress of privacy, perfect for Web3 wizards like you who know Solidity but are new to cryptographic charms.",
      "learningObjectives": [
        "Define FHE and explain its core principles in simple, spellbinding terms",
        "Understand why FHE is a game-changer for data privacy, especially in blockchain realms like DeFi and voting",
        "Connect FHE to everyday privacy puzzles, such as analyzing health data without exposing personal secrets",
        "Trace the enchanted history of FHE and grasp its mechanics at a high level",
        "Appreciate how FHE builds on basic encryption concepts you might already know from your Web3 adventures"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "The Essence of FHE: Brewing Secrets in the Shadows"
        },
        {
          "type": "text",
          "content": "Let's start our incantation with the basics. Fully Homomorphic Encryption is a type of cryptographic spell that allows you to compute directly on encrypted data—called ciphertexts—without ever decrypting it first. The result? A new ciphertext that, when finally decrypted, matches what you'd get from computing on the plain, unencrypted data (plaintext). It's like whispering a command to a locked chest: the contents shuffle and transform inside, but the lock stays sealed until you're ready to open it."
        },
        {
          "type": "text",
          "content": "Why is this revolutionary? Traditional encryption, like the sturdy locks on your treasure vaults (think AES or RSA), forces you to decrypt data before any mixing or measuring—creating a vulnerable moment where thieves (hackers) could strike. FHE eliminates that weak spot entirely. Your data stays encrypted throughout the entire ritual, ensuring privacy even during complex operations."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "The Potion Master's Analogy",
          "content": "Picture yourself as a potion master. Your secret ingredient (data) is encrypted into a mystical vial. You add spells (operations like addition or multiplication) to the vial without breaking the seal. The vial computes internally, and only when you chant the decryption incantation does the final potion emerge—perfect and private."
        },
        {
          "type": "subheader",
          "text": "A Brief History of This Arcane Art"
        },
        {
          "type": "text",
          "content": "The quest for FHE began in the misty annals of 1978, when wizards Ron Rivest, Len Adleman, and Michael Dertouzos first pondered the idea of 'privacy homomorphisms'—encryption that preserves operations. For decades, it remained a theoretical dream, with partial successes along the way. The breakthrough came in 2009, courtesy of cryptographic sage Craig Gentry, who constructed the first fully homomorphic scheme using lattice-based magic (a branch of math involving grids of points in high dimensions)."
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "The Meaning of Homomorphic",
          "content": "No need for deep math here—just know that 'homomorphic' comes from Greek roots meaning 'same shape.' Operations on ciphertexts mirror those on plaintexts, preserving the structure of your spells. Since Gentry's breakthrough, optimizations have made FHE faster and more practical, thanks to companies like Zama."
        },
        {
          "type": "subheader",
          "text": "The Three Types of Homomorphic Spells"
        },
        {
          "type": "text",
          "content": "Not all homomorphic enchantments are created equal. As Zama's lore reveals, there are three tiers of power:"
        },
        {
          "type": "list",
          "items": [
            "**Partially Homomorphic Encryption (PHE)**: This spell masters one type of operation, performed unlimited times. For example, it might handle endless additions (like Paillier encryption) or multiplications (like ElGamal). Ideal for simple brews, such as tallying votes without revealing individual choices. Think of it as a cauldron that only stirs clockwise—effective, but limited.",
            "**Somewhat Homomorphic Encryption (SHE)**: A step up, this allows both additions and multiplications, but only a finite number of times before the magic weakens (due to 'noise' buildup in the ciphertext). It's like a potion that ferments perfectly for a few mixes but sours if overworked.",
            "**Fully Homomorphic Encryption (FHE)**: The pinnacle! Unlimited combinations of additions, multiplications, and beyond—enabling any computation. Zama's tfhe library powers this, turning theory into deployable dApps. With FHE, you can brew infinitely complex elixirs, from machine learning models to financial audits, all in secrecy."
          ]
        },
        {
          "type": "subheader",
          "text": "Real-World Enchantments: Why FHE Matters in Your Realm"
        },
        {
          "type": "text",
          "content": "FHE isn't just academic arcane—it's the key to unlocking privacy in our digital kingdoms. In blockchain, where transparency clashes with secrecy, FHE shines with transformative applications:"
        },
        {
          "type": "list",
          "items": [
            "**Private Medical Diagnosis**: Analyze encrypted health data in the cloud without exposing patient records. Doctors get insights; privacy stays intact.",
            "**Secure Financial Analysis**: Process transactions without revealing account details—perfect for confidential DeFi or fraud detection.",
            "**AI Inference**: Run machine learning models on encrypted inputs, keeping user data hidden from even the AI wizards."
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "FHE in Web3: The fhEVM Revolution",
          "content": "Zama's fhEVM (Fully Homomorphic Ethereum Virtual Machine) integrates FHE into smart contracts. Imagine sealed-bid auctions where bids compute privately, or confidential voting where tallies happen without exposing votes. No more trusting third-party oracles; the blockchain itself becomes a private computation engine. Compared to zero-knowledge proofs, FHE excels in scenarios needing ongoing computations on shared encrypted data."
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting for Novice Sorcerers"
        },
        {
          "type": "text",
          "content": "Beware these curses in your FHE journey:"
        },
        {
          "type": "list",
          "items": [
            "**Misconception: FHE is Too Slow for Real Use**: Not completely true. It was compute-intensive (operations can be 100-1000x slower than plaintext), but Zama's optimizations and hardware accelerations closed the gap, and they are now 100x faster FHE from 5 years back",
            "**Overcomplicating the Math**: You don't need a PhD in computing or encryption, Zama's docs handle the heavy lifting. If stuck, refer to their official guides.",
            "**Resource Consumption**: Test on testnets like Sepolia first to avoid gas guzzlers—FHE ops consume more resources."
          ]
        },
        {
          "type": "tip",
          "icon": "zap",
          "title": "Quick Debugging Spell",
          "content": "If your spells fizzle, double-check library versions and consult Zama's troubleshooting forums. Check their GitHub for starter templates to ensure your setup is enchanted correctly."
        },
        {
          "type": "subheader",
          "text": "Key Takeaways: Seal These in Your Spellbook"
        },
        {
          "type": "list",
          "items": [
            "FHE is the spell for computing on encrypted data without decryption, banishing privacy vulnerabilities",
            "From partial to full homomorphic tiers, it evolves to handle any operation, powering Zama's fhEVM for blockchain privacy",
            "Real-world magic: Secure health, finance, and AI without exposure—essential for trustless Web3 dApps",
            "History shows it's no myth: From 1978 theory to 2009 reality, now practical thanks to innovators like Zama"
          ]
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "FHE Workflow: Traditional vs. Homomorphic",
          "code": "// ❌ Traditional Encryption Workflow (VULNERABLE)\nconst secretData = decrypt(encryptedData);  // Data exposed!\nconst result = compute(secretData);         // Processing in the open\nconst output = encrypt(result);             // Re-encrypt\n\n// ✅ FHE Workflow (SECURE)\nconst encryptedResult = computeOnEncrypted(encryptedData);  // Never exposed!\nconst output = decrypt(encryptedResult);     // Only final result revealed\n\n// The magic: operations happen directly on ciphertext\n// Enc(a) + Enc(b) = Enc(a + b)\n// Enc(a) × Enc(b) = Enc(a × b)"
        }
      ],
      "resources": [
        {
          "title": "Zama Official Documentation",
          "url": "https://docs.zama.ai/"
        },
        {
          "title": "fhEVM Documentation",
          "url": "https://docs.zama.ai/fhevm"
        },
        {
          "title": "Introduction to FHE",
          "url": "https://www.zama.ai/introduction-to-homomorphic-encryption"
        }
      ]
    },
    {
      "id": 2,
      "title": "Entering the FHEVM Realm",
      "subtitle": "Basics, Cryptography, Data Types, and Operations",
      "description": "Hello again, privacy pioneers! We're stepping into the fhEVM realm – Zama's clever twist on the Ethereum Virtual Machine that lets you cast confidential spells on the blockchain. Picture it as an enchanted EVM where data stays hidden in ciphertexts, yet computations hum along seamlessly. No more exposing secrets during smart contract executions! This section builds on FHE basics, breaking down fhEVM's nuts and bolts in a straightforward way, with real examples to make it stick. We'll keep the magic light but engaging, focusing on clear explanations so you can confidently build privacy-preserving dApps like our Private Potion Guesser.",
      "learningObjectives": [
        "Explain what fhEVM is and how it integrates FHE into Ethereum-compatible smart contracts",
        "Describe key cryptography concepts like keys, ciphertexts, the TFHE scheme, and noise management",
        "Identify fhEVM's encrypted data types and how they differ from standard Solidity ones",
        "Perform basic operations on encrypted data, understanding examples, limitations, and best practices"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "fhEVM Overview: The Confidential Blockchain Engine"
        },
        {
          "type": "text",
          "content": "fhEVM is Zama's open-source framework that extends the standard EVM to support Fully Homomorphic Encryption. It's essentially an EVM fork with built-in FHE capabilities, allowing smart contracts to compute on encrypted data without decryption. This means your dApps can handle sensitive info – like private guesses in our game – while keeping everything confidential onchain."
        },
        {
          "type": "text",
          "content": "How does it work? fhEVM uses symbolic execution: Instead of computing values directly, it handles 'ciphertext handles' (references to encrypted data). Heavy computations are offloaded to a coprocessor, making it efficient for blockchains. It's compatible with EVM tools like Hardhat and deploys to networks like Sepolia. The magic? Data privacy without sacrificing verifiability – perfect for DeFi, voting, or our potion guessing where the target number stays secret."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Web3 Connection",
          "content": "If you're familiar with Solidity, fhEVM adds a library (tfhe.sol) to your contracts, letting you mix encrypted ops with regular code. It's production-ready, quantum-resistant, and open-source on GitHub."
        },
        {
          "type": "subheader",
          "text": "Cryptography Concepts: The Building Blocks of Privacy"
        },
        {
          "type": "text",
          "content": "Let's demystify the crypto behind fhEVM – no deep math required, just the essentials for building."
        },
        {
          "type": "list",
          "items": [
            "**Public and Private Keys**: fhEVM uses a global public key (fetched via frontend libraries) for encrypting data client-side. The private key is split across a decentralized Key Management System (KMS) using threshold MPC – no single entity holds the full key. This ensures secure decryption only when authorized, with zero-knowledge proofs verifying inputs.",
            "**Ciphertexts**: Your encrypted data! Operations produce new ciphertexts without revealing plaintext. In contracts, they're handled as opaque references to prevent leaks.",
            "**TFHE Scheme**: fhEVM is powered by Zama's TFHE (Threshold Fully Homomorphic Encryption), a lattice-based scheme that's fast for Boolean ops and supports unlimited computations. It's quantum-safe and handles integers up to 256 bits.",
            "**Noise Management**: FHE adds 'noise' to ciphertexts during ops to maintain security. Too much noise? Data becomes undecryptable. TFHE uses programmable bootstrapping to 'refresh' ciphertexts, reducing noise and enabling deep computations without limits."
          ]
        },
        {
          "type": "tip",
          "icon": "lock",
          "title": "Privacy Guarantee",
          "content": "These concepts ensure your dApp's privacy: Encrypt once, compute forever, decrypt only at the end."
        },
        {
          "type": "subheader",
          "text": "Data Types in fhEVM: Encrypted Twins of Solidity Staples"
        },
        {
          "type": "text",
          "content": "fhEVM introduces prefixed 'e' types for encrypted data, mirroring Solidity's but with privacy superpowers. They store ciphertexts, not values, so you can't peek inside – that's the point!"
        },
        {
          "type": "list",
          "items": [
            "**ebool**: Encrypted boolean for true/false decisions",
            "**euintX**: Encrypted unsigned integers (e.g., euint8 for 8-bit, up to euint256 for big numbers). Use smaller bits for efficiency",
            "**eaddress**: Encrypted Ethereum addresses",
            "**External Types**: Like externalEuint8 for handling frontend-encrypted inputs"
          ]
        },
        {
          "type": "text",
          "content": "Difference from standard? Regular uint is plaintext; euint is ciphertext. Cast with FHE.asEuintX(value) for plaintext to encrypted, or handle external inputs directly."
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Data Types Example",
          "code": "import { FHE, euint8 } from \"@fhevm/solidity/lib/FHE.sol\";\n\n// Encrypt plaintext as euint8\neuint8 secretNumber = FHE.asEuint8(42); // Produces an encrypted version of 42"
        },
        {
          "type": "subheader",
          "text": "Supported Operations: Casting Spells on Ciphertexts"
        },
        {
          "type": "text",
          "content": "Using the FHE library (imported from @fhevm/solidity/lib/FHE.sol), fhEVM supports ops via FHE functions. They're like Solidity ops but privacy-preserving."
        },
        {
          "type": "list",
          "items": [
            "**Arithmetic**: Add (FHE.add), subtract (FHE.sub), multiply (FHE.mul), min/max (FHE.min/max)",
            "**Bitwise**: AND (FHE.and), OR (FHE.or), XOR (FHE.xor)",
            "**Comparisons**: Equal (FHE.eq), not equal (FHE.ne), less than (FHE.lt), greater than (FHE.gt), etc.",
            "**Advanced**: Select (FHE.select for if-else on encrypted conditions), random (FHE.randEuint8 for onchain randomness)"
          ]
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Operation Examples",
          "code": "// Arithmetic: Add two encrypted integers\neuint32 sum = FHE.add(a, b);\n\n// Bitwise: OR encrypted values\neuint16 result = FHE.or(x, y);\n\n// Comparison: Check equality\nebool isEqual = FHE.eq(guess, target);\n\n// Advanced: Conditional select\neuint64 choice = FHE.select(condition, optionA, optionB);"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Import Errors**: Always import '@fhevm/solidity/lib/FHE.sol'; missing it causes 'FHE not found'",
            "**Gas Overruns**: FHE ops cost more - optimize by using smaller euint types and test on local nodes",
            "**Type Mismatches**: Operations need matching types; cast with FHE.asEuintX"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "fhEVM brings FHE to EVM via TFHE, using symbolic execution for private computations",
            "Crypto essentials: Global keys, ciphertexts, noise refreshed via bootstrapping",
            "Data types like euintX enable encrypted logic; operations mirror Solidity but secure",
            "Master these for dApps where privacy wins – with awareness of gas and limits"
          ]
        }
      ],
      "resources": [
        {
          "title": "fhEVM Solidity Guides",
          "url": "https://docs.zama.ai/protocol/solidity-guides"
        },
        {
          "title": "FHE Operations Documentation",
          "url": "https://docs.zama.ai/protocol/solidity-guides/smart-contract/operations"
        }
      ]
    },
    {
      "id": 3,
      "title": "Brewing Our First Confidential Potion",
      "subtitle": "Project Overview, Tools, and Prerequisites",
      "description": "Excited yet? Let's outline our star project: the Private Potion Guesser dApp! It's a fun, hands-on way to apply fhEVM – users guess an encrypted potion's 'strength' (a secret number), and the contract checks it privately without spilling secrets. Think of it as a magical lockbox: Your guess goes in encrypted, computation happens inside, and only the 'yes/no' peeks out. This section previews the build, lists tools, and checks prereqs, keeping things simple and motivating so you're geared up to code.",
      "learningObjectives": [
        "Describe the dApp's mechanics and how fhEVM ensures privacy in the guessing process",
        "List key tools and their roles in the full-stack build",
        "Verify prerequisites like software versions and setups",
        "Grasp the end-to-end workflow to build excitement for coding"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Project Overview: A Private Guessing Adventure"
        },
        {
          "type": "text",
          "content": "In the Private Potion Guesser:"
        },
        {
          "type": "list",
          "items": [
            "The smart contract holds an encrypted target number (set by the deployer)",
            "On the frontend, users encrypt their guess using the public key",
            "The contract compares (e.g., FHE.eq) on ciphertexts, returning an encrypted result",
            "User decrypts offchain via threshold KMS, seeing score on leaderboard"
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Privacy Win",
          "content": "Blockchain sees only ciphertexts – no leaks! It's simple yet demonstrates the full FHE loop: Encrypt → Compute → Decrypt. We'll build it end-to-end, deploying to Sepolia for real-world feel."
        },
        {
          "type": "text",
          "content": "Why this project? It's beginner-accessible, creative (inspired by Zama's secret number ideas), and teaches core fhEVM without overwhelm."
        },
        {
          "type": "subheader",
          "text": "Required Tools: Your Builder's Toolkit"
        },
        {
          "type": "text",
          "content": "Here's what we'll use – all free and Web3-standard:"
        },
        {
          "type": "list",
          "items": [
            "**Hardhat**: Compiles, tests, deploys contracts. Great for local sims",
            "**fhevmjs**: Frontend JS lib for encryption/decryption with fhEVM's keys",
            "**Wagmi/Viem**: Handles wallet connections and contract calls (e.g., MetaMask integration)",
            "**React/Next.js**: Builds the UI – inputs, buttons, results display",
            "**Sepolia Testnet**: Safe Ethereum playground; use Alchemy/Infura for RPC",
            "**MetaMask**: Wallet for testing interactions and funding"
          ]
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "Tool Integration",
          "content": "These snap together: Hardhat for backend, React for frontend, fhevmjs bridging encryption."
        },
        {
          "type": "subheader",
          "text": "Prerequisites: Check Your Setup"
        },
        {
          "type": "text",
          "content": "Before brewing:"
        },
        {
          "type": "list",
          "items": [
            "**Node.js**: v18+ (LTS recommended; check with `node -v`)",
            "**Package Manager**: NPM or Yarn",
            "**Git**: For cloning templates",
            "**MetaMask**: Add Sepolia (Chain ID 11155111), fund via faucet",
            "**Basic Skills**: Solidity basics, React hooks; no FHE needed – we'll teach that!"
          ]
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Quick Verify",
          "code": "# Check your versions\nnode -v && npm -v\n\n# Should show compatible versions (Node 18+)"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Node Version Mismatch**: If <18, update via nvm or official site",
            "**Wallet Funding**: No ETH? Transactions fail – use faucets daily",
            "**Editor Setup**: VS Code + Solidity/React extensions for auto-complete and errors"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "The dApp uses fhEVM for private guesses, showcasing encrypt-compute-decrypt",
            "Tools cover full stack; prereqs are straightforward Web3 basics",
            "This sets a fun foundation – ready to clone and code!"
          ]
        }
      ],
      "resources": [
        {
          "title": "Sepolia Faucet",
          "url": "https://sepolia-faucet.com"
        },
        {
          "title": "Node.js Download",
          "url": "https://nodejs.org/"
        }
      ]
    },
    {
      "id": 4,
      "title": "Gathering Your Alchemy Kit",
      "subtitle": "Cloning and Exploring the Boilerplate Repo",
      "description": "Welcome back, aspiring privacy alchemists! In this crucial step, we'll summon our development toolkit by cloning a customized boilerplate repository – imagine it as discovering a well-stocked wizard's workshop, complete with enchanted scrolls and potions ready to mix. The repo we'll use is https://github.com/Destiny-01/potion-brew, a version of PotionBrew with just the frontend. It's cloned from the fhevm-react-template which is designed specifically for building frontend interfaces that interact with fhEVM smart contracts, making it perfect for our Private Potion Guesser dApp.",
      "learningObjectives": [
        "Clone the repo, install dependencies, and set up your local environment with clear, beginner-friendly steps",
        "Understand the overall purpose of the repo as a boilerplate for fhEVM dApps, including how it ties into our Private Potion Guesser",
        "Navigate key folders and files, with explanations of their roles, contents, and why they're important – focusing on the packages folder",
        "Grasp supporting concepts like environment variables (e.g., MNEMONIC) and how they fit into secure development"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Why This Repo? A Quick Overview"
        },
        {
          "type": "text",
          "content": "This repository, is a minimal version of Potion Brew optimized for Fully Homomorphic Encryption (FHE)-enabled dApps on Ethereum. It pairs seamlessly with Zama's fhEVM Hardhat template (which we'll cover in later sections for the backend contracts). The focus here is on the frontend: It provides hooks for interacting with fhEVM contracts, wallet management, and basic UI setups."
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Perfect for Our Project",
          "content": "For our Private Potion Guesser, it's customized to handle encrypted inputs (like guesses) and display private results without leaks. Think of it as your starting canvas – we'll paint our guessing game UI on top."
        },
        {
          "type": "text",
          "content": "If you're wondering, a 'boilerplate' is like a recipe template: It gives you the basics so you can focus on the fun parts, like adding your own spells (code). This one includes dependencies for React, Next.js (for building dynamic apps), Tailwind CSS (for easy styling), and Zama's libraries for FHE magic."
        },
        {
          "type": "subheader",
          "text": "Step-by-Step Setup: Cloning and Installation"
        },
        {
          "type": "text",
          "content": "Let's get hands-on. Open your terminal (that's the command-line interface – on Windows, use Command Prompt or PowerShell; on Mac/Linux, the built-in Terminal app). If you're new to terminals, it's just a text-based way to run commands – no worries, we'll go slow."
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Clone and Install",
          "code": "# 1. Clone the repository\ngit clone https://github.com/Destiny-01/potion-brew.git\n\n# 2. Navigate into the folder\ncd potion-brew\n\n# 3. Install dependencies\nnpm install\n# Or if you prefer Yarn: yarn install"
        },
        {
          "type": "tip",
          "icon": "zap",
          "title": "Installation Tips",
          "content": "If Git isn't installed, download it from https://git-scm.com. If npm install fails, ensure Node.js is installed (download from https://nodejs.org – aim for LTS version 18+). This might take a few minutes as it downloads packages."
        },
        {
          "type": "subheader",
          "text": "Exploring the Repo Structure: Folders and Files"
        },
        {
          "type": "text",
          "content": "The repo is organized as a monorepo, meaning everything lives under the root, with the main action in the packages folder. This keeps things modular – you can build and test parts independently. We'll prioritize the most important areas: the packages/site subfolder (the core frontend), root-level configs, and supporting files."
        },
        {
          "type": "list",
          "items": [
            "**README.md**: Your ultimate guidebook – open this first. It explains the repo's purpose, features (like React integration with fhEVM), requirements (e.g., MetaMask wallet), and quickstart steps.",
            "**package.json**: The project's blueprint. It lists all dependencies (e.g., react and next for the app, tailwindcss for styling) and scripts (commands you can run). Scripts like `npm run dev` start the frontend server",
            "**Configuration Files**: Files like .eslintrc (sets rules for JavaScript linting), .prettierrc (auto-formats code), and tailwind.config.js (customizes Tailwind CSS themes) enforce code quality and style. They keep your code clean and professional"
          ]
        },
        {
          "type": "subheader",
          "text": "The packages Folder: Your Frontend Workshop"
        },
        {
          "type": "text",
          "content": "This is the heart – a sub-package called site houses the actual React app. It's where you'll spend most time adding components for our Potion Guesser (e.g., input fields for guesses, buttons to submit)."
        },
        {
          "type": "list",
          "items": [
            "**packages/site/**: The main frontend directory containing the app's entry points and reusable code. It builds the user interface for interacting with fhEVM contracts – encrypting data, connecting wallets, and displaying results privately",
            "**fhevm/ subfolder**: Contains hooks (reusable functions) for fhEVM interactions. These are the 'spells' that fetch the global public key, handle encryption calls, and manage contract responses. For our dApp, you'll use these to encrypt guesses before sending them to the contract",
            "**hooks/ subfolder**: Custom React hooks for logic separation, including usePotionContract.tsx (a simple hook where we'll write out code to interact with a simple fhEVM contract)",
            "**Other Contents**: Expect src/ or app/ for pages (e.g., main guessing page), components/ for UI bits (like buttons/forms), and styles/ for CSS."
          ]
        },
        {
          "type": "subheader",
          "text": "Key Concepts Explained"
        },
        {
          "type": "list",
          "items": [
            "**MNEMONIC**: This is a 'seed phrase' – a series of 12-24 words (e.g., 'apple banana cat...') that generates your wallet's private keys. In this repo, it's used in environment variables for Hardhat setups. Set it in a .env file (create one in the root: MNEMONIC='your test phrase here'). Never share it – it's like a master key!",
            "**Environment Variables (.env)**: Secure way to store secrets like API keys or MNEMONIC. The repo might reference INFURA_API_KEY (for connecting to Sepolia via Infura). Add them to .env and load with dotenv – keeps your code safe from leaks"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Installation Errors**: If npm install fails, try `npm cache clean --force` or update Node.js",
            "**Git Issues**: Run `git --version` to confirm Git is installed",
            "**Missing Files**: If something's absent, pull updates: `git pull origin main`",
            "**Editor Setup**: Open in VS Code (free from https://code.visualstudio.com) – install extensions for React and Solidity for highlighting"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Cloning and installing gives you a ready fhEVM React boilerplate, focused on packages/site for frontend magic",
            "Files like README.md guide you; hooks in fhevm and metamask handle privacy and wallets",
            "Concepts like MNEMONIC ensure secure dev – now customize for our Potion Guesser!",
            "You're set to ignite the cauldron in the next section"
          ]
        }
      ],
      "resources": [
        {
          "title": "Potion Brew Repository",
          "url": "https://github.com/Destiny-01/potion-brew"
        },
        {
          "title": "Git Download",
          "url": "https://git-scm.com"
        },
        {
          "title": "Node.js Download",
          "url": "https://nodejs.org"
        }
      ]
    },
    {
      "id": 5,
      "title": "Igniting the Cauldron",
      "subtitle": "Setting Up Hardhat, React, and Environment",
      "description": "Alright, alchemists, let's spark the flames! With our repo cloned, this section guides you through configuring the environment for deployment to Sepolia testnet – Ethereum's safe playground for testing dApps. We'll focus on real-world setup: Adding Sepolia to your wallet, funding it with test ETH, deploying your contract, and interacting with it. No local simulations here – we'll go straight to the testnet for hands-on experience.",
      "learningObjectives": [
        "Add and fund the Sepolia testnet in MetaMask for secure interactions",
        "Configure Hardhat with environment variables for Sepolia deployment",
        "Deploy a sample contract to Sepolia and verify it works",
        "Interact with your deployed contract from the frontend, ensuring everything connects smoothly"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Prerequisites Check: Make Sure You're Ready"
        },
        {
          "type": "text",
          "content": "Before diving in, confirm you have:"
        },
        {
          "type": "list",
          "items": [
            "Node.js v18+ installed (run `node -v` in terminal)",
            "MetaMask browser extension (download from https://metamask.io if needed)",
            "Your cloned repo open in an editor like VS Code",
            "An Infura account (free at https://infura.io – sign up for an API key)"
          ]
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Important",
          "content": "Sepolia is free and forgiving – mistakes won't cost real money. If anything's missing, pause and set it up – we'll use these throughout."
        },
        {
          "type": "subheader",
          "text": "Step 1: Adding Sepolia to MetaMask"
        },
        {
          "type": "text",
          "content": "MetaMask is your digital wallet for Ethereum – it holds test ETH and signs transactions."
        },
        {
          "type": "list",
          "items": [
            "Open MetaMask in your browser (click the fox icon)",
            "Click the network dropdown (top center, probably says 'Ethereum Mainnet')",
            "Select 'Add network' > 'Add a network manually'",
            "Fill in the details as shown below",
            "Save – now switch to Sepolia in the dropdown"
          ]
        },
        {
          "type": "code",
          "language": "text",
          "title": "Sepolia Network Configuration",
          "code": "Network Name: Sepolia\nNew RPC URL: https://sepolia.infura.io/v3/YOUR_INFURA_API_KEY\nChain ID: 11155111\nCurrency Symbol: ETH\nBlock Explorer URL: https://sepolia.etherscan.io"
        },
        {
          "type": "tip",
          "icon": "sparkles",
          "title": "Why Sepolia?",
          "content": "Sepolia mimics mainnet but uses fake ETH, perfect for testing our dApp without risks."
        },
        {
          "type": "subheader",
          "text": "Step 2: Funding Your Wallet with Test ETH (Faucet)"
        },
        {
          "type": "text",
          "content": "Deployments need gas (fees), so grab free test ETH from a faucet."
        },
        {
          "type": "list",
          "items": [
            "Go to a Sepolia faucet like https://sepoliafaucet.com or https://www.infura.io/faucet/sepolia",
            "Connect MetaMask (click 'Connect Wallet')",
            "Enter your wallet address (copy from MetaMask: Click account > Copy)",
            "Request ETH – usually 0.1-1 ETH per day. Wait a minute; check balance in MetaMask"
          ]
        },
        {
          "type": "note",
          "icon": "zap",
          "title": "Troubleshooting",
          "content": "If denied, try another faucet or wait 24 hours. Aim for at least 0.5 ETH to cover deployments."
        },
        {
          "type": "subheader",
          "text": "Step 3: Configuring Hardhat for Sepolia"
        },
        {
          "type": "text",
          "content": "Hardhat is our tool for compiling and deploying Solidity contracts. We'll set it up with env vars for security."
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Create .env File",
          "code": "# In your repo root, create a .env file\ntouch .env\n\n# Add these lines (replace with your actual values):\nINFURA_API_KEY=your_infura_key_here\nPRIVATE_KEY=your_metamask_private_key"
        },
        {
          "type": "tip",
          "icon": "lock",
          "title": "Security Warning",
          "content": "PRIVATE_KEY is your wallet's secret key – never commit this file to Git! Add .env to .gitignore if not there. Use a test account only!"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Edit hardhat.config.js",
          "code": "require('@nomicfoundation/hardhat-toolbox');\nrequire('dotenv').config();\n\nmodule.exports = {\n  solidity: '0.8.24',\n  networks: {\n    sepolia: {\n      url: `https://sepolia.infura.io/v3/${process.env.INFURA_API_KEY}`,\n      accounts: [process.env.PRIVATE_KEY]\n    }\n  }\n};"
        },
        {
          "type": "text",
          "content": "This tells Hardhat to use Sepolia with your keys. Install Hardhat plugins if needed:"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Install Dependencies",
          "code": "npm install --save-dev @nomicfoundation/hardhat-toolbox dotenv"
        },
        {
          "type": "subheader",
          "text": "Step 4: Deploying to Sepolia"
        },
        {
          "type": "text",
          "content": "Let's deploy a placeholder contract (we'll replace with PotionGuesser later)."
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "contracts/Placeholder.sol",
          "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Placeholder {\n  string public message = \"Hello Sepolia!\";\n}"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Compile Contract",
          "code": "npx hardhat compile"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "scripts/deploy.js",
          "code": "async function main() {\n  const Placeholder = await ethers.getContractFactory('Placeholder');\n  const contract = await Placeholder.deploy();\n  await contract.waitForDeployment();\n  console.log('Deployed to:', await contract.getAddress());\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Deploy to Sepolia",
          "code": "npx hardhat run scripts/deploy.js --network sepolia\n\n# Watch for the transaction hash\n# Check on https://sepolia.etherscan.io (paste address)"
        },
        {
          "type": "subheader",
          "text": "Step 5: Verifying Deployment"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Install Etherscan Plugin",
          "code": "npm install --save-dev @nomiclabs/hardhat-etherscan"
        },
        {
          "type": "text",
          "content": "Add to hardhat.config.js: etherscan: { apiKey: 'your_etherscan_api_key' } (get free from https://etherscan.io/register)"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Verify Contract",
          "code": "npx hardhat verify --network sepolia YOUR_CONTRACT_ADDRESS"
        },
        {
          "type": "subheader",
          "text": "Step 6: Interacting with Sepolia from Frontend"
        },
        {
          "type": "text",
          "content": "Now connect the React app to your deployed contract."
        },
        {
          "type": "list",
          "items": [
            "In packages/site, update any contract address placeholders with your deployed address",
            "Start Frontend: `cd packages/site && npm run dev` – opens at localhost:3000",
            "In browser, connect MetaMask (ensure on Sepolia). Use demo hooks to call your contract",
            "If errors: Check console for RPC issues; refresh MetaMask"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**No ETH**: Faucet again if deployment fails",
            "**Key Errors**: Double-check .env spelling; restart terminal",
            "**Gas Limits**: If 'out of gas,' increase in Hardhat config: `gas: 3000000`",
            "**Network Issues**: Verify Infura API key is correct and active",
            "Use Etherscan to monitor transactions – search your address"
          ]
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Sepolia setup with MetaMask and faucets enables real testnet deploys",
            "Hardhat with env vars (like PRIVATE_KEY) handles secure deployments",
            "Interaction confirms frontend-backend link – you're ready for the contract!",
            "Real-world testing on Sepolia prepares you for production deployment"
          ]
        }
      ],
      "resources": [
        {
          "title": "MetaMask Download",
          "url": "https://metamask.io"
        },
        {
          "title": "Sepolia Faucet",
          "url": "https://sepoliafaucet.com"
        },
        {
          "title": "Infura Dashboard",
          "url": "https://infura.io"
        },
        {
          "title": "Sepolia Etherscan",
          "url": "https://sepolia.etherscan.io"
        }
      ]
    },
    {
      "id": 6,
      "title": "Crafting the Enchanted Contract",
      "subtitle": "From Plain to Private Potion Guessing",
      "description": "Greetings, code conjurers! In this pivotal section, we'll forge the core of our Private Potion Guesser dApp: the Potion.sol smart contract. We'll begin by examining a basic non-FHE version to highlight its privacy shortcomings, then upgrade it to harness fhEVM's power, ensuring guesses and targets remain shrouded in encryption. Assume you're starting with a skeleton file where the function contents are empty – we'll guide you on filling them line by line, explaining what each line does, why it's there, and where to place it in the file.",
      "learningObjectives": [
        "Contrast a standard Solidity guessing contract with its privacy-enhanced fhEVM counterpart",
        "Construct the Potion.sol contract line by line, understanding each component's role in maintaining data privacy",
        "Test the contract to confirm it handles encrypted operations correctly"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "The Non-FHE Version: Exposing the Elixir"
        },
        {
          "type": "text",
          "content": "To appreciate FHE's magic, let's consider a simple non-private guessing contract. Create a temporary file like PlainPotion.sol in your contracts/ folder to experiment (you can delete it later). This version stores and compares values in plaintext, making everything visible on the blockchain."
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "PlainPotion.sol - Non-Private Version",
          "code": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\ncontract PlainPotion {\n    uint8 internal target;\n\n    function setTarget(uint8 _target) public {\n        target = _target;\n    }\n\n    function guess(uint8 _guess) public view returns (bool) {\n        return _guess == target;\n    }\n}"
        },
        {
          "type": "note",
          "icon": "alert-triangle",
          "title": "Privacy Flaw",
          "content": "The target and guesses are stored and compared openly. Anyone scanning transaction data or the contract state can see the values – no secrecy, like brewing in an open pot. This defeats our privacy goal for the potion strength guessing game."
        },
        {
          "type": "subheader",
          "text": "Upgrading to fhEVM: Building the Private Version"
        },
        {
          "type": "text",
          "content": "Now, let's build Potion.sol in the contracts/ folder. Start with an empty file and add lines as instructed. We'll use fhEVM's TFHE library for encrypted types and operations, ensuring computations happen on ciphertexts."
        },
        {
          "type": "text",
          "content": "**Step 1: Add the License and Pragma (Top of File)**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "License and Pragma",
          "code": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;"
        },
        {
          "type": "note",
          "icon": "info",
          "title": "Why These Lines?",
          "content": "The license specifies usage rights (BSD-3 is permissive). Pragma declares the Solidity version for compatibility – ^0.8.24 means 0.8.24 or higher in the 0.8 series."
        },
        {
          "type": "text",
          "content": "**Step 2: Import the TFHE Library**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Import Statement",
          "code": "import \"fhevm/lib/TFHE.sol\";"
        },
        {
          "type": "note",
          "icon": "sparkles",
          "title": "Why Import TFHE?",
          "content": "This brings in Zama's TFHE library, which provides encrypted types (like euint8) and functions (like eq, reencrypt). Place it here to make these available throughout the contract. Without it, you'll get errors about undefined types."
        },
        {
          "type": "text",
          "content": "**Step 3: Declare the Contract and Target Variable**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Contract Declaration",
          "code": "contract Potion {\n    euint8 internal target;"
        },
        {
          "type": "note",
          "icon": "lock",
          "title": "Understanding euint8",
          "content": "This creates a storage variable 'target' as an encrypted 8-bit unsigned integer (euint8 from TFHE). 'internal' means it's accessible within the contract but not publicly readable, keeping the encrypted potion strength hidden. Use euint8 for small numbers (0-255) to save gas; larger guesses could use euint16/32."
        },
        {
          "type": "text",
          "content": "**Step 4: Add the setTarget Function**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "setTarget Function",
          "code": "    function setTarget(bytes calldata encryptedTarget) public {\n        target = TFHE.asEuint8(encryptedTarget);\n    }"
        },
        {
          "type": "note",
          "icon": "key",
          "title": "How setTarget Works",
          "content": "This function takes encrypted input as bytes (calldata for efficiency) and converts it to euint8 using TFHE.asEuint8. Why? The input comes encrypted from the frontend; this safely casts it for onchain storage. The target stays encrypted from the start, allowing the deployer to set the initial secret target post-deployment."
        },
        {
          "type": "text",
          "content": "**Step 5: Add the guess Function**"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "guess Function",
          "code": "    function guess(bytes calldata encryptedGuess, bytes32 publicKey) public view returns (bytes memory) {\n        ebool isEqual = TFHE.eq(target, TFHE.asEuint8(encryptedGuess));\n        return TFHE.reencrypt(isEqual, publicKey);\n    }\n}"
        },
        {
          "type": "note",
          "icon": "zap",
          "title": "How guess Works",
          "content": "This view function (no state change, gas-efficient) takes an encrypted guess and user's public key. It uses TFHE.eq to compare the encrypted target and casted guess, storing the result as an encrypted bool (ebool). Then TFHE.reencrypt reencrypts the ebool under the user's public key and returns it as bytes. Why? This allows only the user (with their private key) to decrypt the result offchain, maintaining end-to-end privacy. The comparison happens homomorphically without decryption!"
        },
        {
          "type": "subheader",
          "text": "Complete Contract: Ready to Deploy"
        },
        {
          "type": "text",
          "content": "Here's the full Potion.sol contract assembled. Copy this into your contracts/ folder:"
        },
        {
          "type": "code",
          "language": "solidity",
          "title": "Potion.sol - Complete Private Contract",
          "code": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\n\ncontract Potion {\n    euint8 internal target;\n\n    function setTarget(bytes calldata encryptedTarget) public {\n        target = TFHE.asEuint8(encryptedTarget);\n    }\n\n    function guess(bytes calldata encryptedGuess, bytes32 publicKey) public view returns (bytes memory) {\n        ebool isEqual = TFHE.eq(target, TFHE.asEuint8(encryptedGuess));\n        return TFHE.reencrypt(isEqual, publicKey);\n    }\n}"
        },
        {
          "type": "subheader",
          "text": "Testing for Correctness"
        },
        {
          "type": "text",
          "content": "To verify your contract works, create test/Potion.test.js in the tests/ folder. This Hardhat test simulates deployment, setting target, guessing, and decrypting:"
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "Potion.test.js",
          "code": "const { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { createInstance } = require(\"fhevmjs\");\n\ndescribe(\"Potion\", function () {\n  let potion, instance, deployer;\n\n  before(async function () {\n    [deployer] = await ethers.getSigners();\n    const Potion = await ethers.getContractFactory(\"Potion\");\n    potion = await Potion.deploy();\n    instance = await createInstance({ chainId: 31337 }); // Local or Sepolia ID\n  });\n\n  it(\"should set encrypted target and guess correctly\", async function () {\n    const encryptedTarget = instance.encrypt8(42);\n    await potion.setTarget(encryptedTarget);\n\n    const userKeys = instance.generateKeypair();\n    const encryptedGuess = instance.encrypt8(42);\n    const reencrypted = await potion.guess(encryptedGuess, userKeys.publicKey);\n\n    const result = instance.decrypt(await potion.getAddress(), reencrypted, userKeys.privateKey);\n    expect(result).to.equal(1); // 1 for true in bool\n  });\n});"
        },
        {
          "type": "tip",
          "icon": "terminal",
          "title": "Running Tests",
          "content": "Run the test with: npx hardhat test. This confirms the private equality works without leaks. If you see errors, check that fhevmjs is installed and your Hardhat config is correct."
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Import Errors**: Ensure TFHE.sol is installed via npm or in the right path. Check your remappings.txt if using Foundry/Hardhat.",
            "**Type Mismatches**: Use bytes for inputs; TFHE.asEuint8 handles conversion from encrypted bytes to euint8.",
            "**Gas Issues**: Test on Sepolia; optimize by using small euint types. If 'out of gas', increase in Hardhat config: gas: 3000000.",
            "**Undefined TFHE**: Double-check import path and that fhevm library is installed: npm install fhevm"
          ]
        },
        {
          "type": "tip",
          "icon": "lightbulb",
          "title": "Pro Tip",
          "content": "Use Etherscan to monitor transactions on Sepolia. Search your contract address to verify deployments and interactions. Remember: even though operations are encrypted, transaction hashes and addresses are still public!"
        }
      ],
      "resources": [
        {
          "title": "Zama TFHE Library Documentation",
          "url": "https://docs.zama.ai/fhevm"
        },
        {
          "title": "fhEVM Solidity Library",
          "url": "https://github.com/zama-ai/fhevm"
        },
        {
          "title": "Hardhat Testing Guide",
          "url": "https://hardhat.org/hardhat-runner/docs/guides/test-contracts"
        },
        {
          "title": "fhevmjs Documentation",
          "url": "https://docs.zama.ai/fhevm/guides/frontend"
        }
      ]
    },
    {
      "id": 7,
      "title": "Launching the Spell",
      "subtitle": "Deploying the Contract and Integrating Frontend",
      "description": "Hey, spellbinders! Now that your PotionGuesser contract is crafted, it's time to deploy it to Sepolia and weave it into the frontend for user interactions. We'll use Hardhat for deployment and integrate with Wagmi and RainbowKit for wallet connections in the React app. Based on the completed demo repo, we've identified removed code sections like deployment scripts, ABI imports, and Wagmi configs – we'll guide you on re-adding them exactly where they belong, with explanations.",
      "learningObjectives": [
        "Deploy the PotionGuesser to Sepolia with Hardhat, including verification",
        "Add the ABI to the frontend for contract interactions",
        "Configure Wagmi and RainbowKit in App.tsx for chain support and wallet connects",
        "Use useContractWrite in components for submitting guesses"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Step 1: Preparing Deployment"
        },
        {
          "type": "text",
          "content": "Ensure hardhat.config.js in root includes the toolbox and dotenv for environment variables. This configuration loads secrets and sets up network connections."
        },
        {
          "type": "code",
          "language": "javascript",
          "title": "hardhat.config.js - Root Configuration",
          "code": "require(\"@nomicfoundation/hardhat-toolbox\");\nrequire(\"dotenv\").config();\nrequire(\"@nomiclabs/hardhat-etherscan\");\n\nmodule.exports = {\n  solidity: \"0.8.24\",\n  networks: {\n    sepolia: {\n      url: `https://sepolia.infura.io/v3/${process.env.INFURA_API_KEY}`,\n      accounts: [process.env.PRIVATE_KEY]\n    }\n  },\n  etherscan: {\n    apiKey: process.env.ETHERSCAN_API_KEY // From etherscan.io\n  }\n};"
        },
        {
          "type": "note",
          "icon": "package",
          "title": "Install Dependencies",
          "content": "If not already installed, run: npm install --save-dev @nomiclabs/hardhat-etherscan. This enables contract verification on Etherscan."
        },
        {
          "type": "subheader",
          "text": "Step 2: Creating the Deployment Script"
        },
        {
          "type": "text",
          "content": "Create a TypeScript deployment script that uses ethers to factory the contract, deploy it, and log the address for frontend use."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "scripts/deploy.ts",
          "code": "import { ethers } from \"hardhat\";\n\nasync function main() {\n  const PotionGuesser = await ethers.getContractFactory(\"PotionGuesser\");\n  const potionGuesser = await PotionGuesser.deploy();\n  await potionGuesser.waitForDeployment();\n  const address = await potionGuesser.getAddress();\n  console.log(\"PotionGuesser deployed to:\", address);\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});"
        },
        {
          "type": "tip",
          "icon": "terminal",
          "title": "Why TypeScript?",
          "content": "Using TypeScript provides type safety and better IDE support. The script uses the ethers library to interact with the blockchain and deploy your contract."
        },
        {
          "type": "subheader",
          "text": "Step 3: Deploying and Verifying"
        },
        {
          "type": "text",
          "content": "Follow these steps to deploy your contract to Sepolia testnet:"
        },
        {
          "type": "list",
          "items": [
            "**Compile**: Run npx hardhat compile to generate artifacts and ABI",
            "**Deploy**: Run npx hardhat run scripts/deploy.ts --network sepolia",
            "**Verify**: Run npx hardhat verify --network sepolia DEPLOYED_ADDRESS"
          ]
        },
        {
          "type": "note",
          "icon": "save",
          "title": "Save the Address",
          "content": "Copy the deployed contract address from the console output. You'll need to paste it in frontend files as CONTRACT_ADDRESS for the app to interact with your contract."
        },
        {
          "type": "subheader",
          "text": "Step 4: Adding ABI to Frontend"
        },
        {
          "type": "text",
          "content": "The ABI (Application Binary Interface) defines the contract's function signatures. Create a new folder and file for the ABI."
        },
        {
          "type": "code",
          "language": "json",
          "title": "src/abi/PotionGuesserABI.json",
          "code": "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"encryptedTarget\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"setTarget\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"encryptedGuess\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"publicKey\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"guess\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]"
        },
        {
          "type": "tip",
          "icon": "file-json",
          "title": "Getting the ABI",
          "content": "Find the complete ABI in artifacts/contracts/PotionGuesser.sol/PotionGuesser.json after compilation. Copy just the 'abi' array into your frontend file."
        },
        {
          "type": "subheader",
          "text": "Step 5: Integrating Wagmi and RainbowKit"
        },
        {
          "type": "text",
          "content": "Install the required packages for wallet connection and contract interaction:"
        },
        {
          "type": "code",
          "language": "bash",
          "title": "Install Frontend Dependencies",
          "code": "cd packages/site\nnpm install wagmi viem @rainbow-me/rainbowkit @tanstack/react-query connectkit"
        },
        {
          "type": "text",
          "content": "Create a Wagmi configuration file that sets up Sepolia chain and wallet connectors:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/lib/wagmi.ts",
          "code": "import { getDefaultConfig } from 'connectkit';\nimport { createConfig } from 'wagmi';\nimport { sepolia } from 'viem/chains';\n\nexport const config = createConfig(\n  getDefaultConfig({\n    chains: [sepolia],\n    appName: \"Private Potion Guesser\",\n    walletConnectProjectId: 'your_id_here' // Get from walletconnect.com\n  })\n);"
        },
        {
          "type": "note",
          "icon": "link",
          "title": "WalletConnect Project ID",
          "content": "Sign up at walletconnect.com to get a free project ID. This enables WalletConnect support for mobile wallets and other providers."
        },
        {
          "type": "text",
          "content": "Update App.tsx to wrap your application with the necessary providers:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/App.tsx - Provider Setup",
          "code": "import { Toaster } from \"@/components/ui/toaster\";\nimport { Toaster as Sonner } from \"@/components/ui/sonner\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { WagmiProvider } from \"wagmi\";\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\nimport { config } from \"./lib/wagmi\";\nimport { Landing } from \"./pages/Landing\";\nimport { Game } from \"./pages/Game\";\nimport NotFound from \"./pages/NotFound\";\nimport { RainbowKitProvider } from \"@rainbow-me/rainbowkit\";\nimport \"@rainbow-me/rainbowkit/styles.css\";\nimport { useEffect, useState } from \"react\";\nimport { initializeFHE } from \"./lib/fhe\";\n\nconst queryClient = new QueryClient();\n\nconst App = () => {\n  // FHE initialization will be added in Section 8\n  return (\n    <WagmiProvider config={config}>\n      <QueryClientProvider client={queryClient}>\n        <RainbowKitProvider>\n          <TooltipProvider>\n            <Sonner />\n            <Toaster />\n            <BrowserRouter>\n              <Routes>\n                <Route path=\"/\" element={<Landing />} />\n                <Route path=\"/game\" element={<Game />} />\n                <Route path=\"*\" element={<NotFound />} />\n              </Routes>\n            </BrowserRouter>\n          </TooltipProvider>\n        </RainbowKitProvider>\n      </QueryClientProvider>\n    </WagmiProvider>\n  );\n};\n\nexport default App;"
        },
        {
          "type": "tip",
          "icon": "layers",
          "title": "Provider Order Matters",
          "content": "WagmiProvider must wrap QueryClientProvider, which wraps RainbowKitProvider. This ensures proper context propagation throughout your app."
        },
        {
          "type": "text",
          "content": "Update your Game page to include the GuessForm component:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/pages/Game.tsx",
          "code": "import GuessForm from \"../components/GuessForm\";\n\nexport const Game = () => {\n  return (\n    <div className=\"container mx-auto p-4\">\n      <h1 className=\"text-4xl font-bold mb-8\">Private Potion Guesser</h1>\n      <GuessForm />\n    </div>\n  );\n};"
        },
        {
          "type": "text",
          "content": "Create the GuessForm component that uses Wagmi hooks for contract interactions:"
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/components/GuessForm.tsx - Basic Structure",
          "code": "import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi';\nimport PotionGuesserABI from '../abi/PotionGuesserABI.json';\n\nconst CONTRACT_ADDRESS = 'your_deployed_address_here';\n\nfunction GuessForm() {\n  const { isConnected } = useAccount();\n\n  // Encryption logic will be added in Section 8\n  // For now, we'll prepare the contract write\n\n  const { config } = usePrepareContractWrite({\n    address: CONTRACT_ADDRESS,\n    abi: PotionGuesserABI,\n    functionName: 'guess',\n    args: [] // Will add encrypted args in Section 8\n  });\n\n  const { write } = useContractWrite(config);\n\n  if (!isConnected) {\n    return <div>Please connect your wallet</div>;\n  }\n\n  return (\n    <div>\n      <input type=\"number\" min=\"0\" max=\"255\" placeholder=\"Enter your guess\" />\n      <button onClick={() => write?.()}>Submit Guess</button>\n    </div>\n  );\n}\n\nexport default GuessForm;"
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**Transaction Fails**: Check you have enough Sepolia ETH in your wallet for gas fees",
            "**Wagmi Not Connecting**: Ensure walletConnectProjectId is set correctly in wagmi.ts",
            "**ABI Mismatch**: Always recompile and copy the latest ABI after contract changes",
            "**Wrong Network**: Make sure MetaMask is connected to Sepolia testnet"
          ]
        },
        {
          "type": "tip",
          "icon": "compass",
          "title": "Testing Locally",
          "content": "Before deploying to Sepolia, test on a local Hardhat node with: npx hardhat node. Deploy to localhost network first to catch issues early."
        }
      ],
      "resources": [
        {
          "title": "Hardhat Deployment Guide",
          "url": "https://hardhat.org/hardhat-runner/docs/guides/deploying"
        },
        {
          "title": "Wagmi Documentation",
          "url": "https://wagmi.sh/"
        },
        {
          "title": "RainbowKit Setup",
          "url": "https://www.rainbowkit.com/docs/installation"
        },
        {
          "title": "Sepolia Faucet",
          "url": "https://sepoliafaucet.com/"
        }
      ]
    },
    {
      "id": 8,
      "title": "The Art of Secret Infusion",
      "subtitle": "Frontend Encryption and Decryption with FHEVM",
      "description": "Let's seal the secrets! Using fhevmjs, we'll add encryption and decryption to the frontend. From the demo repo, removed code includes FHE init in App, functions in fhe.ts, and logic in GuessForm – we'll add them back with placement and explanations. This completes the privacy circle: encrypt client-side, compute onchain, decrypt client-side.",
      "learningObjectives": [
        "Initialize FHE in App.tsx with proper loading states",
        "Create fhe.ts with functions for initialization, encryption, and decryption",
        "Add key generation, encryption, and decryption logic in GuessForm",
        "Understand the complete FHE workflow from user input to result"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Step 1: Creating FHE Library Functions"
        },
        {
          "type": "text",
          "content": "Create a dedicated file for FHE operations. This module handles initialization, encryption, and decryption, keeping the logic centralized and reusable."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/lib/fhe.ts",
          "code": "import { createInstance } from 'fhevmjs';\n\nexport const initializeFHE = async () => {\n  const instance = await createInstance({ chainId: 11155111 }); // Sepolia\n  return instance;\n};\n\nexport const encryptGuess = (instance: any, value: number) => {\n  const publicKey = instance.getPublicKey();\n  return instance.encrypt8(value, publicKey);\n};\n\nexport const decryptResult = (\n  instance: any,\n  contractAddress: string,\n  reencrypted: string,\n  privateKey: string\n) => {\n  return instance.decrypt(contractAddress, reencrypted, privateKey);\n};"
        },
        {
          "type": "note",
          "icon": "code",
          "title": "What These Functions Do",
          "content": "initializeFHE creates the FHE instance for the Sepolia chain. encryptGuess encrypts a value (0-255) using the network's public key. decryptResult decrypts the reencrypted response using the user's private key."
        },
        {
          "type": "tip",
          "icon": "package",
          "title": "Install fhevmjs",
          "content": "Don't forget to install the library: npm install fhevmjs. This provides all the cryptographic functions needed for client-side FHE operations."
        },
        {
          "type": "subheader",
          "text": "Step 2: Initializing FHE in App.tsx"
        },
        {
          "type": "text",
          "content": "Add FHE initialization logic to App.tsx. This loads the FHE instance on mount, shows a loading state, and handles errors gracefully."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/App.tsx - FHE Initialization",
          "code": "import { useEffect, useState } from \"react\";\nimport { initializeFHE } from \"./lib/fhe\";\n// ... other imports\n\nconst App = () => {\n  const [fheReady, setFheReady] = useState(false);\n  const [fheInstance, setFheInstance] = useState<any>(null);\n\n  useEffect(() => {\n    initializeFHE()\n      .then((instance) => {\n        setFheInstance(instance);\n        setFheReady(true);\n        console.log(\"FHE initialized successfully\");\n      })\n      .catch((err) => {\n        console.error(\"FHE initialization failed:\", err);\n      });\n  }, []);\n\n  if (!fheReady) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-center\">\n          <h2 className=\"text-2xl font-bold mb-2\">Initializing encryption...</h2>\n          <p className=\"text-muted-foreground\">Loading FHE cryptography</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Pass fheInstance to Game via context or props\n  return (\n    <WagmiProvider config={config}>\n      {/* ... rest of providers */}\n    </WagmiProvider>\n  );\n};"
        },
        {
          "type": "note",
          "icon": "clock",
          "title": "Why Loading State?",
          "content": "FHE initialization can take a few seconds as it loads cryptographic parameters. The loading screen prevents users from interacting before the system is ready, avoiding errors."
        },
        {
          "type": "tip",
          "icon": "react",
          "title": "Passing FHE Instance",
          "content": "For cleaner code, consider using React Context to pass fheInstance to child components instead of prop drilling. Create a FHEContext with createContext and useContext."
        },
        {
          "type": "subheader",
          "text": "Step 3: Key Generation, Encryption, and Decryption in GuessForm"
        },
        {
          "type": "text",
          "content": "Now we'll add the complete encryption workflow to the GuessForm component: generate user keypair, encrypt the guess, submit to contract, and decrypt the result."
        },
        {
          "type": "code",
          "language": "typescript",
          "title": "src/components/GuessForm.tsx - Complete Implementation",
          "code": "import { useEffect, useState } from 'react';\nimport { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi';\nimport { encryptGuess, decryptResult } from '../lib/fhe';\nimport PotionGuesserABI from '../abi/PotionGuesserABI.json';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { useToast } from '@/hooks/use-toast';\n\nconst CONTRACT_ADDRESS = 'your_deployed_address_here';\n\ninterface GuessFormProps {\n  fheInstance: any;\n}\n\nfunction GuessForm({ fheInstance }: GuessFormProps) {\n  const { isConnected } = useAccount();\n  const { toast } = useToast();\n  \n  const [userKeys, setUserKeys] = useState<any>(null);\n  const [guess, setGuess] = useState(0);\n  const [encryptedGuess, setEncryptedGuess] = useState<any>(null);\n  const [isEncrypting, setIsEncrypting] = useState(false);\n\n  // Generate user keypair on mount\n  useEffect(() => {\n    if (fheInstance) {\n      const keys = fheInstance.generateKeypair();\n      setUserKeys(keys);\n      console.log('User keypair generated');\n    }\n  }, [fheInstance]);\n\n  // Handle encryption\n  const handleEncrypt = async () => {\n    if (!fheInstance || !guess) return;\n    \n    setIsEncrypting(true);\n    try {\n      const encrypted = encryptGuess(fheInstance, guess);\n      setEncryptedGuess(encrypted);\n      toast({\n        title: \"Guess Encrypted\",\n        description: \"Your guess is now encrypted and ready to submit\"\n      });\n    } catch (error) {\n      console.error('Encryption failed:', error);\n      toast({\n        title: \"Encryption Failed\",\n        description: \"Please try again\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsEncrypting(false);\n    }\n  };\n\n  // Prepare contract write\n  const { config } = usePrepareContractWrite({\n    address: CONTRACT_ADDRESS,\n    abi: PotionGuesserABI,\n    functionName: 'guess',\n    args: [\n      encryptedGuess,\n      '0x', // Attestation (empty for development)\n      userKeys?.publicKey\n    ],\n    enabled: !!encryptedGuess && !!userKeys\n  });\n\n  const { write, data, isSuccess, isLoading } = useContractWrite(config);\n\n  // Handle successful transaction and decrypt result\n  useEffect(() => {\n    if (isSuccess && data && userKeys) {\n      const reencrypted = data; // Response from contract\n      try {\n        const result = decryptResult(\n          fheInstance,\n          CONTRACT_ADDRESS,\n          reencrypted,\n          userKeys.privateKey\n        );\n        \n        toast({\n          title: result ? \"Correct!\" : \"Wrong!\",\n          description: result \n            ? \"You guessed the potion strength correctly!\" \n            : \"Try again with a different guess\"\n        });\n        \n        // Reset form\n        setEncryptedGuess(null);\n        setGuess(0);\n      } catch (error) {\n        console.error('Decryption failed:', error);\n      }\n    }\n  }, [isSuccess, data, userKeys, fheInstance]);\n\n  if (!isConnected) {\n    return (\n      <div className=\"text-center\">\n        <p>Please connect your wallet to play</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div>\n        <label className=\"block mb-2\">Enter your guess (0-255):</label>\n        <Input\n          type=\"number\"\n          min=\"0\"\n          max=\"255\"\n          value={guess}\n          onChange={(e) => setGuess(parseInt(e.target.value) || 0)}\n          disabled={isEncrypting || isLoading}\n        />\n      </div>\n      \n      <div className=\"flex gap-2\">\n        <Button \n          onClick={handleEncrypt}\n          disabled={!guess || isEncrypting || !!encryptedGuess}\n        >\n          {isEncrypting ? 'Encrypting...' : 'Encrypt Guess'}\n        </Button>\n        \n        <Button\n          onClick={() => write?.()}\n          disabled={!encryptedGuess || isLoading}\n          variant=\"default\"\n        >\n          {isLoading ? 'Submitting...' : 'Submit Guess'}\n        </Button>\n      </div>\n      \n      {encryptedGuess && (\n        <p className=\"text-sm text-muted-foreground\">\n          ✓ Guess encrypted and ready to submit\n        </p>\n      )}\n    </div>\n  );\n}\n\nexport default GuessForm;"
        },
        {
          "type": "note",
          "icon": "key",
          "title": "Key Generation Per Session",
          "content": "User keypairs are generated once per session when the component mounts. The private key stays in memory and is never sent anywhere, ensuring only the user can decrypt their results."
        },
        {
          "type": "tip",
          "icon": "shield",
          "title": "Attestation Parameter",
          "content": "The attestation parameter ('0x' in development) would contain a proof in production environments. For testing on Sepolia, an empty bytes value works fine."
        },
        {
          "type": "subheader",
          "text": "Understanding the Complete FHE Flow"
        },
        {
          "type": "list",
          "items": [
            "**Step 1 - Initialize**: Load FHE instance with network parameters on app startup",
            "**Step 2 - Generate Keys**: Create user keypair (public + private) for the session",
            "**Step 3 - Encrypt**: User input is encrypted with network public key before leaving the browser",
            "**Step 4 - Submit**: Encrypted data is sent to the smart contract along with user's public key",
            "**Step 5 - Compute**: Contract performs homomorphic comparison on encrypted data",
            "**Step 6 - Reencrypt**: Contract reencrypts result under user's public key",
            "**Step 7 - Decrypt**: User decrypts the result client-side with their private key"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Pitfalls and Troubleshooting"
        },
        {
          "type": "list",
          "items": [
            "**FHE Not Ready**: Always check if fheInstance exists before calling encryption functions",
            "**Key Loss**: Keys are session-based - if user refreshes, they'll need new keys and can't decrypt old results",
            "**Wrong Key Usage**: Use network public key for initial encryption, user public key for reencryption request",
            "**Type Mismatches**: encrypt8 expects numbers 0-255; validate input ranges before encrypting"
          ]
        },
        {
          "type": "tip",
          "icon": "database",
          "title": "Key Storage Best Practice",
          "content": "Never store private keys in localStorage (persists across sessions). Use in-memory state or sessionStorage at most. Private keys should be ephemeral and session-specific."
        },
        {
          "type": "subheader",
          "text": "Testing the Complete Flow"
        },
        {
          "type": "text",
          "content": "To test your implementation:"
        },
        {
          "type": "list",
          "items": [
            "**Connect Wallet**: Use MetaMask on Sepolia testnet",
            "**Wait for Init**: Ensure 'FHE initialized successfully' appears in console",
            "**Enter Guess**: Input a number between 0-255",
            "**Encrypt**: Click encrypt button and verify encryption success toast",
            "**Submit**: Click submit and approve the MetaMask transaction",
            "**View Result**: After tx confirms, see the decrypted result (correct/wrong)"
          ]
        },
        {
          "type": "note",
          "icon": "check-circle",
          "title": "Privacy Verified",
          "content": "Check the transaction on Etherscan - you'll see encrypted bytes, not the actual guess or result. The blockchain is blind to the plaintext values!"
        }
      ],
      "resources": [
        {
          "title": "fhevmjs Documentation",
          "url": "https://docs.zama.ai/fhevm/guides/frontend"
        },
        {
          "title": "fhevmjs GitHub Repository",
          "url": "https://github.com/zama-ai/fhevmjs"
        },
        {
          "title": "Zama Key Management Guide",
          "url": "https://docs.zama.ai/fhevm/guides/keys"
        },
        {
          "title": "React Context API",
          "url": "https://react.dev/reference/react/useContext"
        }
      ]
    },
    {
      "id": 9,
      "title": "Reflecting on the Brew",
      "subtitle": "Recap, Achievements, and Lessons Learned",
      "description": "Well done, master brewers – your confidential potion is bubbling! Let's pause to reflect on the journey through our Private Potion Guesser dApp. This section recaps the full process in clear steps, celebrates your key achievements, and distills the core lessons on fhEVM's privacy magic. Think of it as tasting your elixir: Savor what you've created, note the flavors (learnings), and ponder how to refine future brews.",
      "learningObjectives": [
        "Recap the end-to-end dApp development process, from FHE basics to frontend integration",
        "Recognize your achievements in building a privacy-focused application",
        "Identify key lessons on fhEVM's strengths, challenges, and real-world applications"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Run-Through: The Complete Brewing Process"
        },
        {
          "type": "text",
          "content": "Here's a step-by-step recap of our adventure, like reviewing a spellbook after a successful incantation:"
        },
        {
          "type": "list",
          "items": [
            "**FHE and fhEVM Foundations (Sections 1-2)**: We unveiled FHE's principles – computing on encrypted data without decryption – and explored fhEVM as Zama's EVM extension for onchain privacy. You learned crypto basics (keys, TFHE scheme), data types (euint8, ebool), and operations (add, eq) with examples.",
            "**Project Setup and Tools (Sections 3-5)**: We outlined the dApp (private guessing game), gathered tools (Hardhat, React, fhevmjs, Wagmi), cloned the boilerplate repo, and configured environments – adding Sepolia to MetaMask, funding with faucets, and setting .env vars for secure deploys.",
            "**Contract Crafting (Section 6)**: Built Potion.sol with encrypted target storage and private comparisons using TFHE.eq and reencrypt, testing via Hardhat to verify privacy.",
            "**Deployment and Integration (Section 7)**: Deployed to Sepolia with scripts/deploy.ts, added ABI to frontend, and integrated Wagmi/RainbowKit in App.tsx for wallet connects and contract writes.",
            "**Encryption Magic (Section 8)**: Added fhevmjs in lib/fhe.ts for init/encrypt/decrypt, generating user keys and handling client-side privacy in GuessForm.tsx."
          ]
        },
        {
          "type": "note",
          "icon": "trophy",
          "title": "The Result",
          "content": "A full dApp where users encrypt guesses, the contract computes privately, and only the caller decrypts the outcome – all on Sepolia for real blockchain feel!"
        },
        {
          "type": "subheader",
          "text": "Achievements: What You've Mastered"
        },
        {
          "type": "text",
          "content": "Give yourself a pat on the back – here's what you've accomplished:"
        },
        {
          "type": "list",
          "items": [
            "**Built a Confidential dApp from Scratch**: Deployed a privacy-preserving guessing game, demonstrating the encrypt-compute-decrypt workflow end-to-end",
            "**Integrated Key Tools Seamlessly**: Combined Hardhat for backend, React/Next.js for UI, Wagmi for interactions, and fhevmjs for FHE – a full-stack Web3 skillset",
            "**Ensured True Privacy**: No data leaks; everything stays encrypted onchain, with offchain decryption for users only",
            "**Tested and Optimized**: Used Hardhat tests to validate logic, aware of gas costs and optimizations like small euint types"
          ]
        },
        {
          "type": "tip",
          "icon": "star",
          "title": "Level Up",
          "content": "These skills position you to tackle advanced apps, like private voting or confidential auctions. You're now part of the privacy-first Web3 movement!"
        },
        {
          "type": "subheader",
          "text": "Lessons Learned: Insights from the Cauldron"
        },
        {
          "type": "list",
          "items": [
            "**Privacy Without Compromise**: fhEVM solves Web3's transparency-privacy tension – computations are verifiable yet secret, ideal for DeFi, health data, or AI inference",
            "**Challenges and Trade-offs**: FHE ops are gas-heavy (optimize with bounded logic, small types); key management is crucial (user keys for reencrypt prevent leaks)",
            "**Broader Impact**: This project shows FHE's potential in real dApps – e.g., sealed-bid auctions where bids compute privately, or machine learning on encrypted inputs",
            "**Best Practices**: Always test locally/Sepolia first; use .env for secrets; modularize with hooks for clean code"
          ]
        },
        {
          "type": "note",
          "icon": "lightbulb",
          "title": "Reflection Exercise",
          "content": "How might you adapt this for a multiplayer version? What other privacy problems could you solve with FHE? Experiment to solidify your knowledge!"
        },
        {
          "type": "subheader",
          "text": "Real-World Applications Beyond Gaming"
        },
        {
          "type": "text",
          "content": "The techniques you've learned apply far beyond guessing games. FHE enables groundbreaking applications:"
        },
        {
          "type": "list",
          "items": [
            "**Private Voting Systems**: Votes encrypted onchain, tallied without revealing individual choices, ensuring democratic integrity",
            "**Confidential DeFi**: Trading, lending, borrowing without exposing positions or wallet balances",
            "**Healthcare on Blockchain**: Medical records stored encrypted, analyzed for insights without compromising patient privacy",
            "**Sealed-Bid Auctions**: Bids remain hidden until reveal time, preventing front-running and manipulation",
            "**Private Gaming**: Game state hidden from players and servers, enabling true fog-of-war mechanics",
            "**Encrypted Machine Learning**: Train models on private datasets without exposing training data"
          ]
        },
        {
          "type": "subheader",
          "text": "Debugging and Troubleshooting Tips"
        },
        {
          "type": "list",
          "items": [
            "**Full App Debug**: Simulate complete workflows locally with Hardhat node before testnet deployment",
            "**Log Encrypted Values**: Display encrypted values as hex strings for verification and debugging",
            "**Gas Estimation**: Use hardhat gas-reporter plugin to identify expensive operations",
            "**Frontend Errors**: Check browser console for fhevmjs initialization and encryption errors",
            "**Contract Events**: Emit events for important state changes to track execution flow"
          ]
        },
        {
          "type": "tip",
          "icon": "terminal",
          "title": "Pro Debugging Tip",
          "content": "Use Etherscan to monitor transactions on Sepolia. You can see the encrypted bytes being passed around, confirming that plaintext values never touch the blockchain!"
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "The workflow – setup, build, deploy, integrate – creates robust private dApps",
            "Achievements include mastering fhEVM tools for encrypted logic",
            "Lessons emphasize optimization, security, and FHE's transformative role in Web3",
            "You're ready to build the next generation of privacy-preserving applications",
            "The encrypt-compute-decrypt pattern is your blueprint for future projects"
          ]
        }
      ],
      "resources": [
        {
          "title": "Zama Use Cases",
          "url": "https://www.zama.ai/use-cases"
        },
        {
          "title": "fhEVM Advanced Tutorials",
          "url": "https://docs.zama.ai/fhevm/tutorials"
        },
        {
          "title": "Privacy in Web3 Research",
          "url": "https://docs.zama.ai/fhevm/fundamentals/why-privacy"
        },
        {
          "title": "FHE Development Best Practices",
          "url": "https://docs.zama.ai/fhevm/guides/best-practices"
        }
      ]
    },
    {
      "id": 10,
      "title": "Sharing the Elixir",
      "subtitle": "Deploying Your dApp, Next Steps, and FHEVM Advantages",
      "description": "Your potion is perfected – now bottle it and share with the world! This final section covers deploying the full frontend to Vercel (or similar), suggests extensions, and reiterates fhEVM's standout benefits. It's like distributing your elixir to fellow alchemists: Make it accessible, inspire builds, and highlight why this tech shines.",
      "learningObjectives": [
        "Deploy the React frontend to Vercel for public access",
        "Plan next steps, like extensions and sharing for feedback or bounties",
        "Explain fhEVM's advantages in privacy, security, and Web3 innovation"
      ],
      "content": [
        {
          "type": "subheader",
          "text": "Deployment: Bottling for the Masses"
        },
        {
          "type": "text",
          "content": "Create a github repo, and push your code there. Host your frontend on Vercel – it's free, fast, and integrates with Github. Head to https://vercel.com. Connect your github account, and deploy the project"
        },
        {
          "type": "subheader",
          "text": "Next Steps: Extending and Sharing Your Brew"
        },
        {
          "type": "text",
          "content": "**Enhance the dApp:**"
        },
        {
          "type": "list",
          "items": [
            "**Add Hints**: Use TFHE.gt/lt for 'too high/low' encrypted feedback without revealing the target",
            "**Multiplayer Guesses**: Store multiple encrypted targets for different players, add leaderboards",
            "**Difficulty Levels**: Add ranges (euint16 for 0-65535) or time limits for challenges",
            "**UI Polish**: Add animations with Framer Motion, sound effects, particle effects for correct guesses",
            "**Score Tracking**: Store encrypted score history onchain for persistent records",
            "**NFT Rewards**: Mint NFTs for players who guess correctly within certain attempts"
          ]
        },
        {
          "type": "text",
          "content": "**Share Your Work:**"
        },
        {
          "type": "list",
          "items": [
            "**Push to GitHub**: Fork the boilerplate, add a comprehensive README with demo link, setup instructions, and video walkthrough",
            "**Social Media**: Tweet about your project with #fhEVM #ZamaAI #Web3Privacy hashtags",
            "**Zama Bounties**: Submit to Zama's bounty program if active (check https://www.zama.ai/bounty) – include repo and demo video",
            "**Community Engagement**: Join Zama's Discord/GitHub for feedback and collaboration",
            "**Developer Portfolio**: Showcase this unique privacy-focused project to potential employers or clients"
          ]
        },
        {
          "type": "code",
          "language": "markdown",
          "title": "Sample README.md",
          "code": "# Private Potion Guesser 🧪\n\nA privacy-preserving guessing game powered by fhEVM.\n\n## ✨ Features\n- Fully encrypted guesses and targets\n- Zero-knowledge gameplay\n- Interactive React UI with Wagmi\n- Deployed on Sepolia testnet\n\n## 🛠 Tech Stack\n- **Smart Contracts**: Solidity + fhEVM (Zama)\n- **Frontend**: React + Next.js\n- **Web3**: Wagmi + RainbowKit\n- **Encryption**: fhevmjs\n- **Testing**: Hardhat\n\n## 🚀 Live Demo\n[View Demo](https://your-app.vercel.app)\n\n## 📦 Setup\n1. Clone repo: `git clone ...`\n2. Install: `npm install`\n3. Configure .env with CONTRACT_ADDRESS\n4. Run: `npm run dev`\n\n## 🎮 How to Play\n1. Connect MetaMask (Sepolia)\n2. Enter your guess (0-255)\n3. Encrypt and submit\n4. Decrypt result privately!\n\n## 🔐 Privacy Guarantees\nAll guesses and comparisons happen on encrypted data. The blockchain never sees plaintext values – only you can decrypt your results!"
        },
        {
          "type": "tip",
          "icon": "video",
          "title": "Demo Video",
          "content": "Record a 2-3 minute walkthrough showing: MetaMask connection, encrypting a guess, submitting to contract, and decrypting the result. Use Loom or OBS for easy screen recording."
        },
        {
          "type": "text",
          "content": "**Dive Deeper:**"
        },
        {
          "type": "list",
          "items": [
            "Explore Zama docs for advanced TFHE operations (conditional logic, encrypted comparisons)",
            "Build a private voting dApp as your next project",
            "Try confidential DeFi applications with encrypted balances",
            "Experiment with encrypted machine learning inference"
          ]
        },
        {
          "type": "subheader",
          "text": "fhEVM Advantages: Why This Magic Matters"
        },
        {
          "type": "text",
          "content": "Let's recap why fhEVM stands out in the privacy-tech landscape:"
        },
        {
          "type": "list",
          "items": [
            "**Unmatched Privacy**: Computes on encrypted data onchain – no trusted third parties, unlike some ZK solutions",
            "**Security and Future-Proofing**: Quantum-resistant TFHE using lattice-based cryptography",
            "**Decentralized KMS**: Key management system prevents single-point failures",
            "**Web3 Innovation**: Enables confidential DeFi (private trades), secure AI (encrypted inference), private gaming, and more",
            "**EVM Composability**: Works seamlessly with existing Solidity knowledge and EVM tools",
            "**Ease for Developers**: Familiar syntax with TFHE additions; no complex trusted setups",
            "**Gas Optimizations**: Continuously improving performance makes FHE more practical"
          ]
        },
        {
          "type": "note",
          "icon": "shield",
          "title": "The Privacy Revolution",
          "content": "fhEVM turns blockchain from a public ledger into a private computation engine. You're building the infrastructure for a privacy-first Web3 future!"
        },
        {
          "type": "subheader",
          "text": "Bounty Program and Recognition"
        },
        {
          "type": "text",
          "content": "Zama occasionally runs bounty programs for innovative fhEVM applications. Here's how to stand out:"
        },
        {
          "type": "list",
          "items": [
            "Polish your repository with clear documentation and code comments",
            "Create a professional demo video (2-3 minutes) showing the dApp in action",
            "Explain the privacy guarantees and why FHE was necessary for your use case",
            "Document challenges faced and how you solved them",
            "Highlight innovative use of TFHE operations",
            "Include comprehensive tests and security considerations"
          ]
        },
        {
          "type": "subheader",
          "text": "Common Deployment Pitfalls"
        },
        {
          "type": "list",
          "items": [
            "**Environment Variables**: Set all required vars in Vercel dashboard (Project Settings → Environment Variables), not just in .env",
            "**CORS Errors**: Add proper headers in next.config.js if making API calls",
            "**Contract Address**: Always update to production contract address before deploying",
            "**Network Mismatch**: Verify frontend connects to correct chain in Wagmi config",
            "**Build Errors**: Test local build (npm run build) before deploying to catch issues early"
          ]
        },
        {
          "type": "tip",
          "icon": "git-branch",
          "title": "Preview Deployments",
          "content": "Use Vercel preview deployments for testing. Each git branch gets its own preview URL for safe experimentation before production."
        },
        {
          "type": "subheader",
          "text": "Join the Privacy-First Movement"
        },
        {
          "type": "text",
          "content": "The fhEVM ecosystem is rapidly growing. Stay connected and keep building:"
        },
        {
          "type": "list",
          "items": [
            "Join Zama's Discord for latest updates, community support, and collaboration",
            "Follow Zama on Twitter/X for announcements and new features",
            "Explore advanced tutorials for DeFi, gaming, and identity applications",
            "Contribute to open-source fhEVM libraries and tools",
            "Attend Web3 conferences and hackathons focusing on privacy",
            "Share your knowledge through blog posts and tutorials"
          ]
        },
        {
          "type": "note",
          "icon": "heart",
          "title": "Final Congratulations",
          "content": "You've completed an incredible journey from FHE basics to a deployed privacy-preserving dApp! The skills you've gained are foundational for the next generation of blockchain applications. Privacy is not just a feature; it's a fundamental right that you can now protect through fhEVM. Keep building, keep experimenting, and keep the magic of privacy alive in your code!"
        },
        {
          "type": "subheader",
          "text": "Key Takeaways"
        },
        {
          "type": "list",
          "items": [
            "Vercel deployment makes your dApp globally accessible with minimal effort",
            "Extensions and sharing foster growth and community engagement",
            "fhEVM's privacy advantages unlock secure, innovative Web3 applications",
            "You're now equipped to build the future of privacy-first blockchain",
            "The encrypt-compute-decrypt pattern is your superpower for confidential dApps"
          ]
        }
      ],
      "resources": [
        {
          "title": "Vercel Documentation",
          "url": "https://vercel.com/docs"
        },
        {
          "title": "Zama Community Discord",
          "url": "https://discord.com/invite/fhe-org"
        },
        {
          "title": "Zama Bounty Programs",
          "url": "https://www.zama.ai/bounties"
        },
        {
          "title": "fhEVM Use Cases",
          "url": "https://www.zama.ai/use-cases"
        },
        {
          "title": "Advanced fhEVM Tutorials",
          "url": "https://docs.zama.ai/fhevm/tutorials"
        }
      ]
    }
  ],
  "quizzes": [
    {
      "sectionId": 1,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What does 'homomorphic' mean in the context of FHE?",
          "options": [
            "Computing on decrypted data",
            "Preserving operations between plaintext and ciphertext",
            "Randomizing data for security",
            "Compressing files magically"
          ],
          "correctAnswer": 1,
          "explanation": "Homomorphic comes from Greek roots meaning 'same shape.' It's all about maintaining that same magical structure—operations on ciphertexts mirror those on plaintexts!"
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "FHE allows _____ on ciphertexts without ever needing to decrypt during the process.",
          "correctAnswer": "computations",
          "explanation": "The core magic of FHE is performing computations (or operations/calculations) directly on encrypted data without decryption. Accepted answers: computations, operations, or calculations."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Arrange these steps in the correct FHE workflow order: (1) Perform operations (2) Encrypt data (3) Decrypt result (4) Get output. What is the correct sequence?",
          "options": [
            "1 → 2 → 3 → 4",
            "2 → 1 → 3 → 4",
            "2 → 3 → 1 → 4",
            "4 → 2 → 1 → 3"
          ],
          "correctAnswer": 1,
          "explanation": "The correct FHE workflow is: First Encrypt plaintext data, then Perform homomorphic operations on the ciphertext, then Decrypt the result, and finally Get the final plaintext output."
        },
        {
          "id": 4,
          "type": "fill-blank",
          "question": "In the potion-brewing analogy, traditional encryption requires opening the _____ to mix ingredients, while FHE mixes blindly inside.",
          "correctAnswer": "cauldron",
          "explanation": "The key difference: Traditional encryption requires opening the cauldron (decrypting) to perform operations, creating a vulnerability. FHE keeps the cauldron sealed throughout the entire process."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "Which company is pioneering FHE integration into Ethereum smart contracts with fhEVM?",
          "options": ["OpenZeppelin", "ConsenSys", "Zama", "Chainlink"],
          "correctAnswer": 2,
          "explanation": "Zama is the groundbreaking company behind fhEVM (Fully Homomorphic Ethereum Virtual Machine), bringing FHE to blockchain and enabling private computation in smart contracts."
        }
      ]
    },
    {
      "sectionId": 6,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "Import _____ for FHE operations in your Solidity contract.",
          "correctAnswer": "fhevm/lib/TFHE.sol",
          "explanation": "The TFHE library from fhevm provides all the encrypted types (like euint8) and operations (like eq, reencrypt) needed for FHE computations."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "Why use TFHE.reencrypt in the guess function?",
          "options": [
            "To decrypt the result onchain",
            "To allow user-private decryption with their key",
            "To store the result publicly",
            "To save gas costs"
          ],
          "correctAnswer": 1,
          "explanation": "TFHE.reencrypt reencrypts the result under the user's public key, allowing only them to decrypt it offchain with their private key. This maintains end-to-end privacy."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "In the private Potion contract, arrange these operations in correct order: (1) Compare encrypted values (2) Receive encrypted guess (3) Return reencrypted result. What is the correct sequence?",
          "options": ["1 → 2 → 3", "2 → 1 → 3", "3 → 2 → 1", "2 → 3 → 1"],
          "correctAnswer": 1,
          "explanation": "The correct flow is: First receive the encrypted guess (2), then compare it with the target using TFHE.eq (1), finally return the reencrypted result (3)."
        },
        {
          "id": 4,
          "type": "fill-blank",
          "question": "What is euint8 used for in the Potion contract?",
          "correctAnswer": "encrypted integers",
          "explanation": "euint8 represents encrypted 8-bit unsigned integers. It allows the contract to store and compute on encrypted values (0-255) while maintaining privacy. Accepted answers: encrypted integers, encrypted numbers, or encrypted values."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "What is the main privacy flaw in the PlainPotion contract?",
          "options": [
            "It uses too much gas",
            "The target and guesses are visible on the blockchain",
            "It doesn't have a constructor",
            "It uses old Solidity syntax"
          ],
          "correctAnswer": 1,
          "explanation": "The PlainPotion contract stores the target and processes guesses in plaintext, making all values visible to anyone scanning the blockchain. This completely defeats the privacy requirement of our guessing game."
        }
      ]
    },
    {
      "sectionId": 7,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "The contract's _____ defines function signatures for frontend interactions.",
          "correctAnswer": "ABI",
          "explanation": "ABI (Application Binary Interface) defines the contract's function signatures, allowing the frontend to call contract methods correctly."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What command deploys the contract to Sepolia?",
          "options": [
            "npx hardhat deploy",
            "npx hardhat run scripts/deploy.ts --network sepolia",
            "npm run deploy-sepolia",
            "hardhat deploy --sepolia"
          ],
          "correctAnswer": 1,
          "explanation": "The correct command is 'npx hardhat run scripts/deploy.ts --network sepolia', which executes the deployment script on the Sepolia testnet."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "In the provider hierarchy, which order is correct?",
          "options": [
            "RainbowKit → Wagmi → QueryClient",
            "QueryClient → RainbowKit → Wagmi",
            "Wagmi → QueryClient → RainbowKit",
            "Wagmi → RainbowKit → QueryClient"
          ],
          "correctAnswer": 2,
          "explanation": "WagmiProvider wraps QueryClientProvider, which wraps RainbowKitProvider. This order ensures proper context propagation."
        },
        {
          "id": 4,
          "type": "fill-blank",
          "question": "Wagmi uses _____ hooks to interact with smart contracts.",
          "correctAnswer": "useContractWrite",
          "explanation": "useContractWrite (and usePrepareContractWrite) are Wagmi hooks that enable writing to smart contracts. Accepted answers: useContractWrite, React hooks, or Wagmi hooks."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "Why verify the contract on Etherscan?",
          "options": [
            "It's required for deployment",
            "It makes the code publicly viewable and trustworthy",
            "It reduces gas costs",
            "It improves contract performance"
          ],
          "correctAnswer": 1,
          "explanation": "Verification makes your contract's source code publicly viewable on Etherscan, building trust and transparency in your dApp."
        }
      ]
    },
    {
      "sectionId": 8,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "The fhevmjs function _____ encrypts values as 8-bit unsigned integers.",
          "correctAnswer": "encrypt8",
          "explanation": "encrypt8 is the fhevmjs function that encrypts values in the range 0-255 as 8-bit unsigned integers (euint8)."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "Why generate user keypairs on the client side?",
          "options": [
            "To save gas costs",
            "To ensure only the user can decrypt their results",
            "To speed up encryption",
            "To reduce server load"
          ],
          "correctAnswer": 1,
          "explanation": "User keypairs ensure that only the user who made the guess can decrypt the result using their private key, maintaining end-to-end privacy."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Arrange the FHE flow steps: (1) Decrypt result (2) Encrypt guess (3) Generate keys (4) Contract computes. What is the correct sequence?",
          "options": [
            "1 → 2 → 3 → 4",
            "3 → 2 → 4 → 1",
            "2 → 3 → 4 → 1",
            "3 → 4 → 2 → 1"
          ],
          "correctAnswer": 1,
          "explanation": "The correct flow is: Generate keys (3), Encrypt guess (2), Contract computes (4), Decrypt result (1). Keys must be generated first, then data is encrypted, processed, and finally decrypted."
        },
        {
          "id": 4,
          "type": "fill-blank",
          "question": "Private keys should be stored in _____ to maintain security.",
          "correctAnswer": "memory",
          "explanation": "Private keys should stay in memory (React state) or sessionStorage at most, never in localStorage. They should be ephemeral and session-specific. Accepted answers: memory, state, or sessionStorage."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "What does the attestation parameter do?",
          "options": [
            "It encrypts the guess",
            "It provides a proof in production (empty in development)",
            "It stores the user's address",
            "It verifies the contract"
          ],
          "correctAnswer": 1,
          "explanation": "The attestation parameter would contain a cryptographic proof in production environments. For testing on Sepolia, an empty bytes value ('0x') works fine."
        }
      ]
    },
    {
      "sectionId": 9,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "The core FHE workflow is: Encrypt, _____, Decrypt",
          "options": ["Deploy", "Compute", "Test", "Share"],
          "correctAnswer": 1,
          "explanation": "The FHE workflow is Encrypt → Compute → Decrypt. Data is encrypted, computations happen on ciphertexts, then results are decrypted."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "Achievement: Built a _____ dApp with fhEVM.",
          "correctAnswer": "privacy-preserving",
          "explanation": "You built a privacy-preserving (or confidential) dApp that keeps all sensitive data encrypted. Accepted answers: privacy-preserving, confidential, or private."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Arrange these tutorial sections: (1) Encryption Magic (2) Foundations (3) Contract Crafting. What is the correct order?",
          "options": ["1 → 2 → 3", "2 → 3 → 1", "3 → 1 → 2", "2 → 1 → 3"],
          "correctAnswer": 1,
          "explanation": "The correct order is: Foundations (sections 1-2), Contract Crafting (section 6), Encryption Magic (section 8)."
        },
        {
          "id": 4,
          "type": "fill-blank",
          "question": "Key lesson: FHE ops are _____, so optimize with small types.",
          "correctAnswer": "gas-intensive",
          "explanation": "FHE operations are gas-intensive (or gas-heavy/expensive) compared to regular operations. Using smaller encrypted types like euint8 helps optimize costs. Accepted answers: gas-intensive, gas-heavy, or expensive."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "Which real-world application is enabled by FHE?",
          "options": [
            "Public transaction logs",
            "Sealed-bid auctions with private bids",
            "Unencrypted data storage",
            "Standard token transfers"
          ],
          "correctAnswer": 1,
          "explanation": "Sealed-bid auctions are a perfect FHE use case – bids remain encrypted and private until the reveal phase, preventing manipulation."
        }
      ]
    },
    {
      "sectionId": 10,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Does Vercel host smart contracts?",
          "options": [
            "Yes, it hosts everything",
            "No, frontend only",
            "Only Solidity files",
            "Yes, but only testnet contracts"
          ],
          "correctAnswer": 1,
          "explanation": "Vercel hosts frontends only (React, Next.js apps). Smart contracts are deployed separately to blockchains like Sepolia via Hardhat."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What is a key fhEVM advantage?",
          "options": [
            "Public onchain computations",
            "Confidential onchain computations",
            "Slower transaction speeds",
            "Higher gas costs only"
          ],
          "correctAnswer": 1,
          "explanation": "fhEVM's key advantage is enabling confidential computations directly onchain without revealing data, maintaining privacy while using blockchain."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "Deploy command: vercel --_____",
          "correctAnswer": "prod",
          "explanation": "The command 'vercel --prod' deploys your application to production. Without --prod, it creates a preview deployment."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which extension idea uses TFHE comparisons?",
          "options": [
            "NFT minting",
            "Adding private hints with gt/lt",
            "Changing UI colors",
            "Social media integration"
          ],
          "correctAnswer": 1,
          "explanation": "Adding private hints using TFHE.gt (greater than) and TFHE.lt (less than) operations would provide encrypted 'too high/low' feedback without revealing the target."
        },
        {
          "id": 5,
          "type": "fill-blank",
          "question": "Share your work with hashtag _____",
          "correctAnswer": "#fhEVM",
          "explanation": "Using #fhEVM (along with #ZamaAI) helps your project reach the privacy-focused Web3 community. Accepted answers: #fhEVM, #ZamaAI, or #Web3Privacy."
        }
      ]
    }
  ],
  "quizzes": [
    {
      "sectionId": 1,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What does 'homomorphic' mean in the context of FHE?",
          "options": [
            "Computing on decrypted data",
            "Preserving operations between plaintext and ciphertext",
            "Randomizing data for security",
            "Compressing files magically"
          ],
          "correctAnswer": 1,
          "explanation": "Homomorphic comes from Greek meaning 'same shape.' It means operations on ciphertexts mirror those on plaintexts, preserving the structure of computations."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "FHE allows __________ on ciphertexts without ever needing to decrypt during the process.",
          "correctAnswer": "computations",
          "alternatives": ["operations", "calculations"],
          "explanation": "FHE enables computations, operations, or calculations on encrypted data without decryption, maintaining privacy throughout."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Which is NOT a real-world application of FHE in blockchain?",
          "options": [
            "Private medical diagnosis",
            "Secure financial analysis",
            "Public transaction broadcasting",
            "Confidential voting systems"
          ],
          "correctAnswer": 2,
          "explanation": "Public transaction broadcasting doesn't require FHE as it's intentionally transparent. FHE is for keeping data private while computing."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "What year did Craig Gentry create the first fully homomorphic encryption scheme?",
          "options": ["1978", "2000", "2009", "2020"],
          "correctAnswer": 2,
          "explanation": "Craig Gentry created the first FHE scheme in 2009 using lattice-based cryptography, turning decades of theory into reality."
        },
        {
          "id": 5,
          "type": "mcq",
          "question": "Which type of homomorphic encryption allows unlimited operations?",
          "options": [
            "Partially Homomorphic Encryption (PHE)",
            "Somewhat Homomorphic Encryption (SHE)",
            "Fully Homomorphic Encryption (FHE)",
            "Basic Homomorphic Encryption (BHE)"
          ],
          "correctAnswer": 2,
          "explanation": "FHE allows unlimited combinations of operations (additions, multiplications, etc.) enabling any computation on encrypted data."
        }
      ]
    },
    {
      "sectionId": 2,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What tool is used for frontend encryption in fhEVM?",
          "options": ["Hardhat", "fhevmjs", "MetaMask", "Wagmi"],
          "correctAnswer": 1,
          "explanation": "fhevmjs is the JavaScript library for client-side encryption and decryption in fhEVM applications."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "To check equality of encrypted values, use: TFHE._____(a, b)",
          "correctAnswer": "eq",
          "explanation": "TFHE.eq performs equality comparison on encrypted values, returning an encrypted boolean (ebool)."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What does 'euint8' represent?",
          "options": [
            "8 ethereum addresses",
            "Encrypted 8-bit unsigned integer",
            "8-byte encryption key",
            "External unit type 8"
          ],
          "correctAnswer": 1,
          "explanation": "euint8 is an encrypted 8-bit unsigned integer type in fhEVM, capable of storing encrypted values from 0-255."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Why use symbolic execution in fhEVM?",
          "options": [
            "To make code look fancy",
            "To handle operations as references, offloading compute for efficiency",
            "To encrypt data automatically",
            "To reduce gas costs to zero"
          ],
          "correctAnswer": 1,
          "explanation": "Symbolic execution handles ciphertext operations as references, offloading heavy computations to coprocessors for blockchain efficiency."
        }
      ]
    },
    {
      "sectionId": 3,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "What is the minimum Node.js version required?",
          "options": ["v14", "v16", "v18", "v20"],
          "correctAnswer": 2,
          "explanation": "Node.js v18 or higher is required for the fhEVM development environment and its dependencies."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "Which testnet is recommended for deployment?",
          "options": ["Goerli", "Sepolia", "Rinkeby", "Ropsten"],
          "correctAnswer": 1,
          "explanation": "Sepolia is the recommended Ethereum testnet for fhEVM deployments, offering stability and faucet availability."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "The dApp uses fhEVM for private guesses, showcasing the _____-compute-_____ pattern.",
          "correctAnswer": "encrypt-decrypt",
          "alternatives": ["encrypt, decrypt"],
          "explanation": "The core FHE pattern is encrypt-compute-decrypt: data is encrypted, operations happen on ciphertext, then results are decrypted."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "How does privacy work in the Private Potion Guesser?",
          "options": [
            "Server-side encryption only",
            "Computations on ciphertexts, decrypt offchain",
            "Blockchain hides all data automatically",
            "Using private transactions"
          ],
          "correctAnswer": 1,
          "explanation": "Privacy is achieved through computations on encrypted ciphertexts onchain, with decryption happening offchain by the user."
        }
      ]
    },
    {
      "sectionId": 4,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Which folder contains fhEVM hooks for encryption?",
          "options": [
            "packages/contracts",
            "packages/site/lib/fhe.ts",
            "src/components",
            "lib/encryption"
          ],
          "correctAnswer": 1,
          "explanation": "The packages/site/lib/fhe.ts folder contains essential hooks for encrypting data, fetching public keys, and interacting with fhEVM contracts."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What does the usePotionContract.ts hook show?",
          "options": [
            "Wallet connection",
            "Basic fhEVM operations",
            "UI styling",
            "API calls"
          ],
          "correctAnswer": 1,
          "explanation": "usePotionContract.tsx is a hook showing how to perform basic fhEVM operations like incrementing an encrypted counter using the useFhevm hook."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "Command to clone: git _____ https://github.com/Destiny-01/potion-brew",
          "correctAnswer": "clone",
          "explanation": "The 'git clone' command downloads a copy of the repository to your local machine."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "How does the hooks folder help in our guessing game?",
          "options": [
            "It styles the UI",
            "It provides hooks to encrypt guesses and decrypt results",
            "It connects to the database",
            "It handles wallet connections only"
          ],
          "correctAnswer": 1,
          "explanation": "The hooks folder provides essential hooks to encrypt guesses client-side and decrypt results, maintaining privacy throughout the game."
        }
      ]
    },
    {
      "sectionId": 5,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "Command to compile Hardhat contracts: npx hardhat _____",
          "correctAnswer": "compile",
          "explanation": "The 'npx hardhat compile' command builds your Solidity contracts, including TFHE imports, generating artifacts for deployment."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What stores sensitive data like MNEMONIC and API keys?",
          "options": [
            "hardhat.config.ts",
            ".env file or hardhat vars",
            "package.json",
            "Public GitHub repo"
          ],
          "correctAnswer": 1,
          "explanation": "Environment variables should be stored in a .env file or using 'npx hardhat vars set' for security. Never commit secrets to version control!"
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What is the default RPC URL for Hardhat's local node?",
          "options": [
            "http://localhost:3000",
            "http://127.0.0.1:8545",
            "http://localhost:8080",
            "http://127.0.0.1:3000"
          ],
          "correctAnswer": 1,
          "explanation": "Hardhat's local node runs at http://127.0.0.1:8545 (Chain ID: 31337) by default, providing a fast testing environment with unlimited gas."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Why run a local Hardhat node instead of deploying directly to testnet?",
          "options": [
            "It's required for production",
            "For fast, free testing without gas costs",
            "Testnets don't support fhEVM",
            "Local nodes are more secure"
          ],
          "correctAnswer": 1,
          "explanation": "Local nodes provide instant, free testing with unlimited gas, perfect for rapid development before deploying to real testnets like Sepolia."
        }
      ]
    },
    {
      "sectionId": 6,
      "questions": [
        {
          "id": 1,
          "type": "fill-blank",
          "question": "Import _____ for FHE operations in Solidity.",
          "correctAnswer": "@fhevm/solidity/lib/FHE.sol",
          "alternatives": ["FHE.sol", "fhevm"],
          "explanation": "The FHE library is imported from @fhevm/solidity/lib/FHE.sol to access encrypted types and operations."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "Why use FHE in smart contracts?",
          "options": [
            "To increase gas costs",
            "To hide computation data and ensure privacy",
            "To make contracts public",
            "To slow down transactions"
          ],
          "correctAnswer": 1,
          "explanation": "FHE is used to hide sensitive data and ensure privacy during computations, preventing exposure on the blockchain."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What does FHE.reencrypt do?",
          "options": [
            "Decrypts data permanently",
            "Encrypts plaintext",
            "Reencrypts result for specific user's private decryption",
            "Compresses ciphertext"
          ],
          "correctAnswer": 2,
          "explanation": "FHE.reencrypt transforms the encrypted result so it can be decrypted by a specific user with their private key."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Compared to standard Solidity, fhEVM gas costs are approximately:",
          "options": [
            "The same",
            "2-5x higher",
            "10-20x higher",
            "100-1000x higher"
          ],
          "correctAnswer": 3,
          "explanation": "FHE operations are computationally intensive, resulting in gas costs that are 100-1000x higher than standard operations."
        }
      ]
    },
    {
      "sectionId": 7,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Is the ABI needed for frontend calls?",
          "options": [
            "No, it's optional",
            "Yes, it defines the contract interface",
            "Only for read operations",
            "Only for write operations"
          ],
          "correctAnswer": 1,
          "explanation": "The ABI (Application Binary Interface) is essential for the frontend to understand and interact with contract functions."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "Deploy command: npx hardhat _____ --network sepolia",
          "correctAnswer": "run scripts/deploy.js",
          "alternatives": ["run", "deploy"],
          "explanation": "The full command 'npx hardhat run scripts/deploy.js --network sepolia' executes the deployment script on Sepolia testnet."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Why verify contracts on Etherscan?",
          "options": [
            "It's required for deployment",
            "For transparency and trust - makes code publicly viewable",
            "To reduce gas costs",
            "To encrypt the contract"
          ],
          "correctAnswer": 1,
          "explanation": "Verification makes your contract code publicly viewable on Etherscan, building trust and transparency with users."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which Wagmi hook is used for contract write operations?",
          "options": [
            "useContractRead",
            "useContractWrite",
            "useContract",
            "useWallet"
          ],
          "correctAnswer": 1,
          "explanation": "useContractWrite is the Wagmi hook for executing write operations (transactions) on smart contracts."
        }
      ]
    },
    {
      "sectionId": 8,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "When does decryption happen in the FHE workflow?",
          "options": [
            "Before computation",
            "After computation on the client side",
            "During computation on blockchain",
            "Never"
          ],
          "correctAnswer": 1,
          "explanation": "Decryption happens after computation, on the client side using the user's private key - never on the blockchain."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "Library for frontend FHE operations: _____",
          "correctAnswer": "fhevmjs",
          "explanation": "fhevmjs is the JavaScript library that handles encryption and decryption on the frontend."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "Why perform client-side encryption?",
          "options": [
            "It's faster",
            "Prevents onchain data leaks by encrypting before submission",
            "It's required by browsers",
            "To reduce bundle size"
          ],
          "correctAnswer": 1,
          "explanation": "Client-side encryption ensures data is already encrypted before it reaches the blockchain, preventing any exposure."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Where should user private keys be stored?",
          "options": [
            "localStorage",
            "Server database",
            "In-memory or sessionStorage only",
            "Public GitHub repo"
          ],
          "correctAnswer": 2,
          "explanation": "User private keys should only be stored in-memory or sessionStorage (temporary), never in persistent storage or servers."
        }
      ]
    },
    {
      "sectionId": 9,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "The core FHE workflow is: Encrypt, _____, Decrypt",
          "options": ["Deploy", "Compute", "Test", "Verify"],
          "correctAnswer": 1,
          "explanation": "The core FHE workflow is Encrypt-Compute-Decrypt: data is encrypted, computation happens on ciphertext, then results are decrypted."
        },
        {
          "id": 2,
          "type": "fill-blank",
          "question": "You successfully deployed your dApp to _____ testnet.",
          "correctAnswer": "Sepolia",
          "explanation": "Throughout this tutorial, we deployed to the Sepolia Ethereum testnet."
        },
        {
          "id": 3,
          "type": "mcq",
          "question": "What is FHE's biggest advantage?",
          "options": [
            "Faster transactions",
            "Lower gas costs",
            "Private onchain computations without trust",
            "Simpler code"
          ],
          "correctAnswer": 2,
          "explanation": "FHE's revolutionary advantage is enabling private computations directly on blockchain without requiring trust in any third party."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which skill did you NOT gain in this tutorial?",
          "options": [
            "FHE smart contract development",
            "Client-side encryption/decryption",
            "Machine learning model training",
            "Full-stack dApp deployment"
          ],
          "correctAnswer": 2,
          "explanation": "This tutorial focused on FHE blockchain development, not machine learning. You learned smart contracts, encryption, and deployment."
        }
      ]
    },
    {
      "sectionId": 10,
      "questions": [
        {
          "id": 1,
          "type": "mcq",
          "question": "Does Vercel host smart contracts?",
          "options": [
            "Yes, it hosts everything",
            "No, frontend only",
            "Only Solidity files",
            "Yes, but only on paid plans"
          ],
          "correctAnswer": 1,
          "explanation": "Vercel is a frontend hosting platform. Smart contracts are deployed to blockchain networks separately."
        },
        {
          "id": 2,
          "type": "mcq",
          "question": "What is a key advantage of fhEVM?",
          "options": [
            "Slower processing",
            "Enhanced data privacy with cryptographic guarantees",
            "Public computation only",
            "Higher gas costs"
          ],
          "correctAnswer": 1,
          "explanation": "fhEVM's key advantage is enhanced data privacy through cryptographic guarantees, enabling trustless confidential computing."
        },
        {
          "id": 3,
          "type": "fill-blank",
          "question": "Command to deploy frontend: _____",
          "correctAnswer": "vercel",
          "explanation": "The 'vercel' command initiates the deployment process to Vercel's platform."
        },
        {
          "id": 4,
          "type": "mcq",
          "question": "Which is a good next step for extending the dApp?",
          "options": [
            "Remove all encryption",
            "Add encrypted hints using FHE.gt/lt comparisons",
            "Make all data public",
            "Delete the contract"
          ],
          "correctAnswer": 1,
          "explanation": "Adding encrypted hints using FHE comparison operations (gt/lt) is a great way to extend the dApp's functionality while maintaining privacy."
        }
      ]
    }
  ]
}
